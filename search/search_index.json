{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"databind","text":"<p>Compatibility: Python 3.6.3+</p> <p>Databind is a library inspired by jackson-databind to de-/serialise Python dataclasses.</p> <p>If you install the <code>databind</code> package, you will get the respective version of the following packages:</p> <ul> <li>databind.core \u2013 Provides the core framework.</li> <li>databind.json \u2013 De-/serialize dataclasses to/from JSON payloads.</li> </ul>"},{"location":"#supported-features","title":"Supported features","text":"Feature Python version Databind version PEP585 3.9 1.2.0 \u2013 current PEP585 (forward references) 3.9 1.3.1? \u2013 current Resolve type parameters of specialised generic types 3.x 1.5.0 \u2013 current <code>typing.TypedDict</code> 3.x 2.0.0 \u2013 current Concretise type variables in parametrised generics 3.x 2.0.0 \u2013 current <p>Copyright \u00a9 2022 \u2013 Niklas Rosenstein</p>"},{"location":"databind.core/","title":"databind.core","text":"<p><code>databind.core</code> provides a jackson-databind inspired framework for data de-/serialization in Python. Unless you are looking to implement support for de-/serializing new data formats, the <code>databind.core</code> package alone might not be what you are looking for (unless you want to use <code>databind.core.dataclasses</code> as a drop-in replacement to the standard library <code>dataclasses</code> module, for that check out the section at the bottom).</p>"},{"location":"databind.core/#known-implementations","title":"Known implementations","text":"<ul> <li>databind.json</li> </ul>"},{"location":"databind.core/#dataclass-extension","title":"Dataclass extension","text":"<p>The standard library <code>dataclasses</code> module does not allow to define non-default arguments after default arguments. You can use <code>databind.core.dataclasses</code> as a drop-in replacement to get this feature. It behaves exactly like the standard library, only that non-default arguments may follow default arguments. Such arguments can be passed to the constructor as positional or keyword arguments.</p> <pre><code>from databind.core import dataclasses\n\n@dataclasses.dataclass\nclass A:\n  value1: int = 42\n\n@dataclasses.dataclass\nclass B(A):\n  value2: str\n\nprint(B(0, 'Hello, World!'))\nprint(B(value2='Answer to the universe'))\n</code></pre> <p>Copyright \u00a9 2020 \u2013 Niklas Rosenstein</p>"},{"location":"databind.json/","title":"databind.json","text":"<p>The <code>databind.json</code> package implements the de-/serialization to or from JSON payloads using the <code>databind.core</code> framework.</p> <p>Check out the Documentation for examples.</p>"},{"location":"databind.json/#built-in-converters","title":"Built-in converters","text":"<p>The following tables shows which types can be deserialized from / serialize to Python types with the native converters provided by the <code>databind.json</code> module:</p> Converter name Types Description <code>AnyConverter</code> <code>typing.Any</code> Accept any value (useful for arbitrary JSON). <code>CollectionConverter</code> <code>typing.Collection[T]</code>, excl. <code>str</code>, <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code> and <code>typing.Mapping[K, V]</code> Converts between native Python collections and JSON arrays. <code>DatetimeConverter</code> <code>datetime.date</code>, <code>datetime.datetime</code>, <code>datetime.time</code> Converts between strings and date/time formats, using ISO 8601 time format by default (can be changed with the <code>databind.core.settings.DateFormat</code> setting). <code>DecimalConverter</code> <code>decimal.Decimal</code> Converts between strings (and ints/floats if strict mode is off, strict mode is on by default) and decimals. The precision can be controlled with the <code>databind.core.settings.Precision</code> setting. <code>EnumConverter</code> <code>enum.Enum</code>, <code>enum.IntEnum</code> Convert between strings and Python enumerations. The serialized form of <code>IntEnum</code> is the integer value, whereas the serialized form of <code>Enum</code> is a string (name of the enumeration value). <code>MappingConverter</code> <code>typing.Mapping[K, V]</code> Converts between Python dicts and JSON objects. (While in theory <code>K</code> can be any type, for JSON <code>K</code> always needs to be <code>str</code>). <code>OptionalConverter</code> <code>typing.Optional[T]</code> Handles optional fields in a schema. <code>PlainDatatypeConverter</code> <code>bytes</code>, <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> Converts between plain datatypes. In non-strict mode (off by default), numeric types will also accept strings as input for the deserialization. <code>SchemaConverter</code> <code>dataclasses.dataclass</code>, <code>typing.TypedDict</code> Converts between Python dataclasses or typed dictionary and JSON objects. <code>UnionConverter</code> <code>typing.Union[...]</code> Handles union types. Unions in JSON can be expressed in a multitide of ways, e.g. using a discriminator key and flat, keyed or nested structure or \"best match\". Check out the examples section of the documentation for more information. <code>LiteralConverter</code> <code>typing.Literal[...]</code> Accepts or rejects a value based on whether it matches one of the values in the literal type hint. <p>The following converters are provided for convenience:</p> Converter name Types Description <code>StringifyConverter</code> n/a A helper that allows to easily create de/serializers from a \"to string\" and \"from string\" function. <p>The following additional types are natively supported by <code>databind.json</code> using <code>StringifyConverter</code>:</p> Types Description <code>uuid.UUID</code> Convert between strings and UUIDs. <code>pathlib.Path</code> Convert between strings and paths. <code>pathlib.PurePath</code> Convert between strings and paths. <code>nr.date.duration</code> Deserialize from ISO 8601 duration strings or the object form, serialize to ISO 8601 strings. <p>Copyright \u00a9 2020 \u2013 Niklas Rosenstein</p>"},{"location":"examples/","title":"Examples","text":"<p>This page shows some common usage examples for using the <code>databind.json</code> library.</p>"},{"location":"examples/#configuration-deserialization","title":"Configuration deserialization","text":"<p>A common use case is to describe the configuration for an application as dataclasses, then deserialize it from a JSON, YAMl or TOML file.</p> <pre><code>from __future__ import annotations\nimport databind.json\nimport dataclasses\nimport tomlib\nfrom pathlib import Path\n\n@dataclasses.dataclass\nclass ServerConfig:\n    host: str\n    port: int = 8080\n\n@dataclasses.dataclass\nclass MainConfig:\n    server: ServerConfig\n\n    @staticmethod\n    def load(path: Path | str) -&gt; MainConfig:\n        data = tomlib.loads(Path(path).read_text())\n        return databind.json.load(data, MainConfig, filename=path)\n\nconfig = MainConfig.load_toml(\"config.toml\")\n</code></pre> <p>An example config TOML file that can be parsed with the above configuration:</p> <pre><code>[server]\nhost = \"localhost\"\nport = 8080\n</code></pre> <p>Note that any extra keys that are not expected per the schema will raise a <code>databind.core.converter.ConversionError</code>.</p> <p>Danger</p> <p>Databind uses Python runtime type annotation introspection using the <code>typeapi</code> package. This requires that all type annotations that databind comes in contact with must be valid expressions in the current Python version, even if <code>from __future__ import annotations</code> is used.</p> <p>This means if your code needs to be compatible with Python versions lower than 3.10 or 3.9 that you can not use the new type union syntax (<code>a | b</code>) or built-in generic aliases (such as <code>t.List[int]</code>) and need to continue to use <code>typing.Union</code>, <code>typing.Optional</code> and <code>typing.List</code>, etc.</p>"},{"location":"examples/#permitting-unknown-keys","title":"Permitting unknown keys","text":"<p>If you would like to permit extra keys to to be present in a payload that is being deserialized without raising a <code>databind.core.converter.ConversionError</code>, you can use the <code>databind.core.settings.ExtraKeys</code> setting to annotate a <code>@dataclass</code>, an annotation or specify it globally to allow extra keys anywhere.</p> <p>When using this setting, you can also record any unexpected keys so you can report them after the deserialization.</p>"},{"location":"examples/#allowing-extra-keys-on-a-dataclass","title":"Allowing extra keys on a dataclass","text":"<pre><code># cat &lt;&lt;EOF | python -\nfrom dataclasses import dataclass\nfrom databind.core.settings import ExtraKeys\nfrom databind.json import load\n\n@ExtraKeys()\n@dataclass\nclass MyClass:\n    a: int\n\nassert load({\"a\": 42, \"b\": \"ignored\"}, MyClass) == MyClass(42)\n</code></pre> <p>Note</p> <p>The <code>ExtraKeys</code> setting does not apply transitively to the members of the dataclass.</p>"},{"location":"examples/#allowing-extra-keys-on-a-dataclass-member","title":"Allowing extra keys on a dataclass member","text":"<pre><code># cat &lt;&lt;EOF | python -\nfrom dataclasses import dataclass\nfrom databind.core.settings import ExtraKeys\nfrom databind.json import load\nfrom typing_extensions import Annotated\n\n@dataclass\nclass Sub:\n    a: int\n\n@dataclass\nclass Main:\n    sub: Annotated[Sub, ExtraKeys()]\n\nassert load({\"sub\": {\"a\": 42, \"b\": \"ignored\"}}, Main) == Main(Sub(42))\n\n# However this:\n\nload({\"sub\": {\"a\": 42}, \"b\": \"not ignored!\"}, Main)\n\n# Gives:\n# databind.core.converter.ConversionError: encountered extra keys: {'b'}\n#  Conversion trace:\n#     $: Type(__main__.Main)\n</code></pre>"},{"location":"examples/#allowing-extra-keys-everywhere","title":"Allowing extra keys everywhere","text":"<p>Providing the <code>ExtraKeys()</code> setting to the <code>settings</code> of a deserialization process will enable it for all schemas, except for those that have a different setting \"closer by\" (you can use <code>ExtraKeys(False)</code> to explicitly not permit extra keys).</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom dataclasses import dataclass\nfrom databind.core.settings import ExtraKeys\nfrom databind.json import load\n\n@dataclass\nclass MyClass:\n    a: int\n\nassert load({\"a\": 42, \"b\": \"ignore\"}, MyClass, settings=[ExtraKeys()]) == MyClass(42)\n</code></pre>"},{"location":"examples/#recording-extra-keys","title":"Recording extra keys","text":"<p>You can also record which extra keys have been encountered to report. This is common if you want to allow but warn about unused keys in a payload.</p> <pre><code># cat &lt;&lt;EOF | python -\nfrom dataclasses import dataclass\nfrom databind.core.settings import ExtraKeys\nfrom databind.core.context import format_context_trace\nfrom databind.json import load\n\n@dataclass\nclass MyClass:\n    a: int\n\nrecorded = []\nassert load({\"a\": 42, \"b\": \"ignore\"}, MyClass, settings=[ExtraKeys(recorder=lambda ctx, keys: recorded.append((ctx, keys)))]) == MyClass(42)\n\nfor ctx, keys in recorded:\n    print(\"warning: unused keys\", keys, \"at\")\n    print(format_context_trace(ctx))\n\n# Gives:\n#\n# warning: unused keys {'b'} at\n#   $: Type(__main__.MyClass)\n</code></pre>"},{"location":"examples/#dynamic-unions-with-union-mappers","title":"Dynamic unions with union mappers","text":"<p>Todo</p>"},{"location":"examples/#unions-with-literal-discriminators","title":"Unions with literal discriminators","text":"<p>When unions are deserialized, they can be accommodated by a \"union mapper\" to identify based on a value in the payload how that payload can be deserialized.</p> <p>However, you can also use <code>Literal</code> type hints on dataca,sses in combination with naive union types. The <code>Literal</code> will fail to deserialize if the value in the payload does not match with the literal value, and naive union types will try all types in the union in order and return the first successfully deserialized type.</p> <p>Note</p> <p>Arguably this is rather inefficient; a better implementation would be to prioritize checking values of literal fields first so we don't need to attempt to deserialize the rest if there's no match.</p> <pre><code># cat &lt;&lt;EOF | python -\nimport dataclasses\nfrom databind.json import load\nfrom typing import Literal\n\n@dataclasses.dataclass\nclass AwsMachine:\n  region: str\n  name: str\n  instance_id: str\n  provider: Literal[\"aws\"] = \"aws\"\n\n@dataclasses.dataclass\nclass AzureMachine:\n  resource_group: str\n  name: str\n  provider: Literal[\"azure\"] = \"azure\"\n\nMachine = AwsMachine | AzureMachine\n\npayload = {\n    \"provider\": \"azure\",\n    \"resource_group\": \"foo\",\n    \"name\": \"bar\",\n}\nassert load(payload, Machine) == AzureMachine(\"foo\", \"bar\")\n</code></pre>"},{"location":"api/databind.core.context/","title":"databind.core.context","text":""},{"location":"api/databind.core.context/#class-root","title":"Class Root","text":"<pre><code>class Root(enum.Enum)\n</code></pre> <p>[view_source]</p> <p>A singleton to represent that a Context is pointing to the root of the payload.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#class-location","title":"Class Location","text":"<pre><code>@dataclasses.dataclass(frozen=True)\nclass Location()\n</code></pre> <p>[view_source]</p> <p>Represents a location in a file.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#filename","title":"filename","text":"<p>The name of the file.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#line","title":"line","text":"<p>The line number in the file.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#column","title":"column","text":"<p>The column number in the file.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#class-context","title":"Class Context","text":"<pre><code>@dataclasses.dataclass\nclass Context()\n</code></pre> <p>[view_source]</p> <p>The context is constructed by the ObjectMapper and passed to an applicable Converter to convert value according to the datatype.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#parent","title":"parent","text":"<p>The parent context.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#direction","title":"direction","text":"<p>The direction (i.e. deserialization or serialization).</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#value","title":"value","text":"<p>The value to convert.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#datatype","title":"datatype","text":"<p>The expected datatype of the value to inform the converter of what to convert the value from or to.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#settings","title":"settings","text":"<p>A list of Settings that are to be taken into account by the converter which can potentialy impact the conversion process.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#key","title":"key","text":"<p>The key or index under which value is present in the source material relative to the parent context. This is <code>None</code> only for the root value in the same source. The value must be <code>Context.ROOT</code> if the context has no parent.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#location","title":"location","text":"<p>The location of the value in the source material.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#convert_func","title":"convert_func","text":"<p>A function to dispatch the further conversion of a Context.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#get_setting","title":"get_setting","text":"<pre><code>def get_setting(setting_type: t.Type[\"T_Setting\"]) -&gt; \"T_Setting | None\"\n</code></pre> <p>[view_source]</p> <p>Retrieve a setting by type that for the current context.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#spawn","title":"spawn","text":"<pre><code>def spawn(value: t.Any,\n          datatype: t.Union[TypeHint, t.Any],\n          key: t.Union[int, str, None],\n          location: t.Optional[Location] = None) -&gt; \"Context\"\n</code></pre> <p>[view_source]</p> <p>Spawn a sub context with a new value, datatype, key and optionally a new location. If the location is not overwritten, the parent filename is inherited, but not line number and column.</p> <p>Arguments:</p> <ul> <li><code>value</code> - The value to convert.</li> <li><code>datatype</code> - The datatype of value. If this is not already a <code>TypeHint</code>, it will be converted to one   using <code>TypeHint()</code>.</li> <li><code>key</code> - The key or index at which the value can be found relative to the parent.</li> <li><code>location</code> - The location of the new value. If not specified, the parent filename is inherited but not the   line number and column.</li> </ul> <p>Returns:</p> <p>A new Context object that has self as its parent.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#convert","title":"convert","text":"<pre><code>def convert() -&gt; t.Any\n</code></pre> <p>[view_source]</p> <p>Invoke the convert_func with self.</p> <p></p> <p></p>"},{"location":"api/databind.core.context/#format_context_trace","title":"format_context_trace","text":"<pre><code>def format_context_trace(ctx: Context) -&gt; str\n</code></pre> <p>[view_source]</p> <p>Formats a trace for the given context that is convenient to inspect in case of errors to understand where the context is pointing to in the payload that is being converted.</p>"},{"location":"api/databind.core.converter/","title":"databind.core.converter","text":""},{"location":"api/databind.core.converter/#class-converter","title":"Class Converter","text":"<pre><code>class Converter(abc.ABC)\n</code></pre> <p>[view_source]</p> <p>Interface for converting a value from one representation to another.</p> <p></p> <p></p>"},{"location":"api/databind.core.converter/#convert","title":"convert","text":"<pre><code>def convert(ctx: \"Context\") -&gt; t.Any\n</code></pre> <p>[view_source]</p> <p>Convert the value in ctx to another value.</p> <p>The default implementation will dispatch to serialize() and deserialize() depending on the direction given by the context. Because these methods raise <code>NotImplementedError</code>, an instance of Converter without custom logic will effectively be a no-op.</p> <p>Argument: ctx: The conversion context that contains the direction, value, datatype, settings, location and allows you to recursively continue the conversion process for sub values.</p> <p>Raises:</p> <ul> <li><code>NotImplementedError</code> - If the converter does not support the conversion for the given context.</li> <li><code>NoMatchingConverter</code> - If the converter is delegating to other converters, to point out that none   of its delegates can convert the value.</li> </ul> <p>Returns:</p> <p>The new value.</p> <p></p> <p></p>"},{"location":"api/databind.core.converter/#class-module","title":"Class Module","text":"<pre><code>class Module(Converter)\n</code></pre> <p>[view_source]</p> <p>A module is a collection of Converters.</p> <p></p> <p></p>"},{"location":"api/databind.core.converter/#class-conversionerror","title":"Class ConversionError","text":"<pre><code>class ConversionError(Exception)\n</code></pre> <p>[view_source]</p> <p>For any errors that occur during conversion.</p> <p></p> <p></p>"},{"location":"api/databind.core.converter/#class-nomatchingconverter","title":"Class NoMatchingConverter","text":"<pre><code>class NoMatchingConverter(ConversionError)\n</code></pre> <p>[view_source]</p> <p>If no converter matched to convert the value and datatype in the context.</p> <p></p> <p></p>"},{"location":"api/databind.core.converter/#class-delegatetoclassmethodconverter","title":"Class DelegateToClassmethodConverter","text":"<pre><code>class DelegateToClassmethodConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>This converter delegaes to the methods defined by name to perform serialization and deserialization of a type. This converter is usually used in conjunction with settings that override the converteer to be used in a specifc scenario (e.g. such as de/serializing JSON with the <code>databind.json.settings.JsonConverter</code> setting).</p>"},{"location":"api/databind.core.dataclasses/","title":"databind.core.dataclasses","text":"<p>Provides a wrapper for <code>dataclasses.dataclass</code> and <code>dataclasses.field</code> that supports non-default arguments following default arguments. The arguments can be specified as positional arguments if the intermediate default arguments are populated as well, or as keyword arguments. The module is supposed to be a drop-in replacement of wherever <code>dataclasses</code> is used.</p> <p>Requires the <code>databind.mypy</code> module to support type checking.</p> <p>Note: <code>make_dataclass</code> is not currently overridden, so it will not support non-default arguments following default arguments.</p> <p></p> <p></p>"},{"location":"api/databind.core.dataclasses/#dataclass","title":"dataclass","text":"<pre><code>def dataclass(cls=None, **kwargs)\n</code></pre> <p>[view_source]</p> <p>A wrapper for the <code>dataclasses.dataclass()</code> decorator that allows non-default arguments to follow default arguments.</p> <p></p> <p></p>"},{"location":"api/databind.core.dataclasses/#field","title":"field","text":"<pre><code>def field(*, annotations=None, metadata=None, **kwargs)\n</code></pre> <p>[view_source]</p> <p>A wrapper for <code>dataclasses.field()</code> that accepts an additional \"annotations\" argument that will propagated into the field's \"databind.core.annotations\" metadata field.</p>"},{"location":"api/databind.core.mapper/","title":"databind.core.mapper","text":""},{"location":"api/databind.core.mapper/#class-objectmapper","title":"Class ObjectMapper","text":"<pre><code>class ObjectMapper(t.Generic[T, U])\n</code></pre> <p>[view_source]</p> <p>The object mapper is responsible for dispatching the conversion process into a Module.</p> <p>The type parameter T represents the deserialized type, while U represents the serialized type.</p> <p></p> <p></p>"},{"location":"api/databind.core.mapper/#convert","title":"convert","text":"<pre><code>def convert(\n        direction: \"Direction\",\n        value: t.Any,\n        datatype: \"TypeHint | t.Any\",\n        location: \"Location | None\" = None,\n        settings: \"SettingsProvider | t.List[Setting] | None\" = None) -&gt; t.Any\n</code></pre> <p>[view_source]</p> <p>Convert a value according to the given datatype.</p> <p>Arguments:</p> <ul> <li><code>direction</code> - The direction, i.e. either deserialization or serialization.</li> <li><code>value</code> - The value to convert.</li> <li><code>datatype</code> - The datatype. If not already a <code>TypeHint</code> instance, it will be converted using <code>TypeHint()</code>.</li> <li><code>location</code> - The location of where value is coming from. Useful to specify to make debugging easier.</li> <li><code>settings</code> - A list of settings, in which case they will be treated as global settings in addition to the   mapper's settings, or an entirely different SettingsProvider instance (for which it is recommended that   it is taking the ObjectMapper's settings into account, for example by passing them for the   <code>Settings.parent</code>).</li> </ul> <p>Raises:</p> <ul> <li><code>ConversionError</code> - For more generic errosr during the conversion process.</li> <li><code>NoMatchingConverter</code> - If at any point during the conversion a datatype was encountered for which no matching   converter was found.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.core.mapper/#serialize","title":"serialize","text":"<pre><code>def serialize(\n        value: T,\n        datatype: \"TypeHint | t.Any\",\n        filename: \"str | None\" = None,\n        settings: \"SettingsProvider | t.List[Setting] | None\" = None) -&gt; U\n</code></pre> <p>[view_source]</p> <p>Serialize value according to the its datatype.</p> <p></p> <p></p>"},{"location":"api/databind.core.mapper/#deserialize","title":"deserialize","text":"<pre><code>def deserialize(\n        value: U,\n        datatype: \"TypeHint | t.Any\",\n        filename: \"str | None\" = None,\n        settings: \"SettingsProvider | t.List[Setting] | None\" = None) -&gt; T\n</code></pre> <p>[view_source]</p> <p>Deserialize value according to the its datatype.</p>"},{"location":"api/databind.core.schema/","title":"databind.core.schema","text":""},{"location":"api/databind.core.schema/#class-field","title":"Class Field","text":"<pre><code>@dataclasses.dataclass\nclass Field()\n</code></pre> <p>[view_source]</p> <p>Describes a field in a schema.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#datatype","title":"datatype","text":"<p>The datatype of the field.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#required","title":"required","text":"<p>Whether the field is required to be present, if this is <code>False</code> and the field does not have a default or <code>default_factorty</code>, the field value will not be passed to the schema constructor. Even if a default or default_factory is present, if he field is required it must be present in the payload being deserialized.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#default","title":"default","text":"<p>The default value for the field, if any.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#default_factory","title":"default_factory","text":"<p>The default value factory for the field, if any.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#flattened","title":"flattened","text":"<p>Indicates whether the field is to be treated \"flat\". If the datatype is a structured type that has fields of its own, those fields should be treated as if expanded into the same level as this field.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#aliases","title":"aliases","text":"<pre><code>@property\ndef aliases() -&gt; t.Tuple[str, ...]\n</code></pre> <p>[view_source]</p> <p>For convience, the aliases described in the datatype#'s annotations are listed here. Do note however, that during the conversion process, the Alias setting should still be looked up through Context.get_setting() and this field should be ignored. It serves only a introspective purpose. Returns an empty tuple if no alias setting is present in the type hint.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#class-schema","title":"Class Schema","text":"<pre><code>@dataclasses.dataclass\nclass Schema()\n</code></pre> <p>[view_source]</p> <p>A Schema describes a set of fields with a name and datatype.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#fields","title":"fields","text":"<p>A dictionary that maps the field descriptions in the schema. The key is the name of the field in code. Given an instance of an object that complies to a given Schema, this is the name by which the value of the field should be read using attribute lookup.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#constructor","title":"constructor","text":"<p>A function that constructs an instance of a Python object that this schema represents given a dictionary as keyword arguments of the deserialized field values. Fields that are not present in the source payload and a that do not have a default value will not be present in the passed dictionary.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#type","title":"type","text":"<p>The underlying native Python type associated with the schema.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#annotations","title":"annotations","text":"<p>Annotation metadata that goes with the schema, possibly derived from a <code>AnnotatedTypeHint</code> hint or the underlying Python type object.</p> <p></p> <p></p>"},{"location":"api/databind.core.schema/#convert_to_schema","title":"convert_to_schema","text":"<pre><code>def convert_to_schema(hint: TypeHint) -&gt; Schema\n</code></pre> <p>[view_source]</p> <p>Convert the given type hint to a Schema.</p> <p>The function delegates to convert_dataclass_to_schema() or convert_typed_dict_to_schema().</p> <p>Arguments:</p> <ul> <li><code>hint</code> - The type hint to convert. If it is a <code>AnnotatedTypeHint</code> hint, it will be unwrapped.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the type hint is not supported.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.core.schema/#convert_dataclass_to_schema","title":"convert_dataclass_to_schema","text":"<pre><code>def convert_dataclass_to_schema(\n        dataclass_type: t.Union[type, GenericAlias, ClassTypeHint]) -&gt; Schema\n</code></pre> <p>[view_source]</p> <p>Converts a Python class that is decorated with <code>dataclasses.dataclass()</code> to a Schema.</p> <p>The function will respect the Required setting if it is present in a field's datatype if, and only if, the setting occurs in the root type hint, which must be a <code>typing.Annotated</code> hint.</p> <p>Arguments:</p> <ul> <li><code>dataclass_type</code> - A Python type that is a dataclass, or a generic alias of a dataclass.</li> </ul> <p>Returns:</p> <p>A schema that represents the dataclass. If a generic alias was passed, fields of which the type hint contained   type parameters will have their type parameters substituted with the respective arguments present in the alias.</p> <p>Example:</p> <pre><code>import dataclasses\nfrom typing import Generic, TypeVar\nfrom typeapi import TypeHint\nfrom databind.core.schema import convert_dataclass_to_schema, Field, Schema\nT = TypeVar('T')\n@dataclasses.dataclass\nclass A(Generic[T]):\n  a: T\nassert convert_dataclass_to_schema(A[int]) == Schema({'a': Field(TypeHint(int))}, A)\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.core.schema/#convert_typed_dict_to_schema","title":"convert_typed_dict_to_schema","text":"<pre><code>def convert_typed_dict_to_schema(typed_dict: TypedDictProtocol) -&gt; Schema\n</code></pre> <p>[view_source]</p> <p>Converts the definition of a <code>typing.TypedDict</code> to a Schema.</p> <p>Note</p> <p>This function will take into account default values assigned on the class-level of the typed dict (which is usually only relevant if the class-style declaration method was used, but default values can be assigned to the function-style declared type as well). Fields that have default values are considered not-required even if the declaration specifies them as required.</p> <p>Be aware that right-hand side values on <code>typing.TypedDict</code> classes are not allowed by Mypy.</p> <p>Also note that <code>typing.TypedDict</code> cannot be mixed with <code>typing.Generic</code>, so keys with a generic type in the typed dict are not possible (state: 2022-03-17, Python 3.10.2).</p> <p>Todo</p> <p>Support understanding <code>typing.Required</code> and <code>typing.NotRequired</code>.</p> <p>Example:</p> <pre><code>from databind.core.schema import convert_typed_dict_to_schema, Schema, Field\nfrom typing import TypedDict\nfrom typeapi import TypeHint\nclass Movie(typing.TypedDict):\n  name: str\n  year: int = 0\nassert convert_typed_dict_to_schema(Movie) == Schema({\n  'name': Field(TypeHint(str)),\n  'year': Field(TypeHint(int), False, 0),\n}, Movie)\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.core.schema/#get_fields_expanded","title":"get_fields_expanded","text":"<pre><code>def get_fields_expanded(\n    schema: Schema,\n    convert_to_schema: t.Callable[[TypeHint], Schema] = convert_to_schema\n) -&gt; t.Dict[str, t.Dict[str, Field]]\n</code></pre> <p>[view_source]</p> <p>Returns a dictionary that contains an entry for each flattened field in the schema, mapping to another dictionary that contains all fields expanded from the flattened field's sub-schema.</p> <p>Given a schema like the following example, this function returns something akin to the below.</p> Schema <pre><code>Schema1:\na: int\nb: Schema2, flattened=True\n\nSchema2:\nc: str\nd: Schema3, flattened=True\n\nSchema3:\ne: int\n</code></pre> Result <pre><code>{\n\"b\": {\n\"c\": Field(str),\n\"e\": Field(int)\n}\n}\n\n**Arguments**:\n\n- `schema` - The schema to compile the expanded fields for.\n- `convert_to_schema` - A function that accepts a `TypeHint` and converts it to a schema.\n  Defaults to the [convert_to_schema()](#pydoc:databind.core.schema.convert_to_schema) function.\n\n  !!! note\n\n  The top-level dictionary returned by this function contains _only_ those fields that are\n  flattened and should be \"composed\" of other fields.\n</code></pre>"},{"location":"api/databind.core.settings/","title":"databind.core.settings","text":""},{"location":"api/databind.core.settings/#class-settingsprovider","title":"Class SettingsProvider","text":"<pre><code>class SettingsProvider(abc.ABC)\n</code></pre> <p>[view_source]</p> <p>Interface for providing settings.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-settings","title":"Class Settings","text":"<pre><code>class Settings(SettingsProvider)\n</code></pre> <p>[view_source]</p> <p>This class is used as a container for other objects that serve as a provider of settings that may taken into account during data conversion. Objects that provide settings are instances of Setting subclasses, such as <code>FieldAlias</code> or DateFormat.</p> <p>Depending on the type of setting, they may be taken into account if present on a field of a dataclass, or globally from an instance of the Settings class that is passed to the ObjectMapper, or both. Which settings are recognized and considered depends also on the implementation of the converter(s) being used.</p> <p>The Settings class provides capabilities to supply global settings, as well as supplying settings conditionally based on the type that is being looked at by the ObjectMapper at the given point in time.</p> <p>Example:</p> <pre><code>from databind.core.settings import DateFormat, Priority, Settings, Strict\nsettings = Settings()\nsettings.add_global(DateFormat('.ISO_8601', priority=Priority.HIGH))\nsettings.add_local(int, Strict(false))\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.core.settings/#add_global","title":"add_global","text":"<pre><code>def add_global(setting: \"Setting\") -&gt; None\n</code></pre> <p>[view_source]</p> <p>Add a global setting.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#add_local","title":"add_local","text":"<pre><code>def add_local(type_: type, setting: \"Setting\") -&gt; None\n</code></pre> <p>[view_source]</p> <p>Add a setting locally for a particular Python type. If that Python type is encountered, the settings are combined with any other settings that are found for the type.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#add_conditional","title":"add_conditional","text":"<pre><code>def add_conditional(predicate: t.Callable[[\"Context\"], bool],\n                    setting: \"Setting\") -&gt; None\n</code></pre> <p>[view_source]</p> <p>Adds a setting conditional on the given predicate.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#add_provider","title":"add_provider","text":"<pre><code>def add_provider(provider: t.Callable[[\"Context\"], t.List[\"Setting\"]]) -&gt; None\n</code></pre> <p>[view_source]</p> <p>Add a provider callback that is invoked for every conversion context to provide additional settings that the subsequent converter should have access to.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#get_setting","title":"get_setting","text":"<pre><code>def get_setting(context: \"Context\",\n                setting_type: t.Type[T_Setting]) -&gt; \"T_Setting | None\"\n</code></pre> <p>[view_source]</p> <p>Resolves the highest priority instance of the given setting type relevant to the current context. The places that the setting is looked for are, in order:</p> <ol> <li>If the context's datatype is <code>AnnotatedTypeHint</code>, look for it in the <code>AnnotatedTypeHint.metadata</code>. Otherwise,    use the wrapped type in the following steps.</li> <li>If the datatype is a <code>ClassTypeHint</code>, look for it as a class setting, then subsequently in the settings added    with add_local().</li> <li>Check the setting providers added with add_provider() or add_conditional().</li> <li>Look for it in the global settings.</li> <li>Delegate to the parent settings provider (if any).</li> </ol> <p>If multiple settings are find using any of these steps, the setting with the highest priority among the settings is returned. If multiple settings have the same priority, the setting found first via the above order is returned.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-priority","title":"Class Priority","text":"<pre><code>class Priority(enum.IntEnum)\n</code></pre> <p>[view_source]</p> <p>The priority for settings determines their order in the presence of multiple conflicting settings. Settings should default to using the <code>NORMAL</code> priority. The other priorities are used to either prevent overriding a field setting globally or to enforce overriding of local field settings globally using Settings.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-setting","title":"Class Setting","text":"<pre><code>class Setting()\n</code></pre> <p>[view_source]</p> <p>Base class for types of which instances represent a setting to be taken into account during data conversion. Every setting has a priority that is used to construct and order or to determine the single setting to use in the presence of multiple instances of the same setting type being present.</p> <p>Settings are usually attached to dataclass fields using <code>typing.Annotated</code>, or added to a Settings object for applying the setting globally, but some subclasses may support being used as decorators to attach the setting to a type object. Such settings would registers themselves under the <code>__databind_settings__</code> attribute (created if it does not exist) such that it can be picked up when introspected by a converter. Such Setting subclasses should inherit from <code>DecoratorSetting</code> instead.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-classdecoratorsetting","title":"Class ClassDecoratorSetting","text":"<pre><code>class ClassDecoratorSetting(Setting)\n</code></pre> <p>[view_source]</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#__call__","title":"__call__","text":"<pre><code>def __call__(type_: t.Type[T]) -&gt; t.Type[T]\n</code></pre> <p>[view_source]</p> <p>Decorate the class type_ with this setting, adding the setting to its <code>__databind_settings__</code> list (which is created if it does not exist) and sets <code>bound_to</code>. The same setting instance cannot decorate multiple types.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#get_highest_setting","title":"get_highest_setting","text":"<pre><code>def get_highest_setting(settings: t.Iterable[T_Setting]) -&gt; \"T_Setting | None\"\n</code></pre> <p>[view_source]</p> <p>Return the first, highest setting of settings.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#get_class_settings","title":"get_class_settings","text":"<pre><code>def get_class_settings(\n    type_: type, setting_type: t.Type[T_ClassDecoratorSetting]\n) -&gt; t.Iterable[T_ClassDecoratorSetting]\n</code></pre> <p>[view_source]</p> <p>Returns all matching settings on type_.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#get_class_setting","title":"get_class_setting","text":"<pre><code>def get_class_setting(\n    type_: type, setting_type: t.Type[T_ClassDecoratorSetting]\n) -&gt; \"T_ClassDecoratorSetting | None\"\n</code></pre> <p>[view_source]</p> <p>Returns the first instance of the given setting_type on type_.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#get_annotation_setting","title":"get_annotation_setting","text":"<pre><code>def get_annotation_setting(\n        type_: TypeHint,\n        setting_type: t.Type[T_Setting]) -&gt; \"T_Setting | None\"\n</code></pre> <p>[view_source]</p> <p>Returns the first setting of the given setting_type from the given type hint from inspecting the metadata of the <code>AnnotatedTypeHint</code>. Returns <code>None</code> if no such setting exists or if type_ is not an <code>AnnotatedTypeHint</code> instance.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-booleansetting","title":"Class BooleanSetting","text":"<pre><code>@dataclasses.dataclass(frozen=True)\nclass BooleanSetting(Setting)\n</code></pre> <p>[view_source]</p> <p>Base class for boolean settings.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-alias","title":"Class Alias","text":"<pre><code>class Alias(Setting)\n</code></pre> <p>[view_source]</p> <p>The Alias setting is used to attach one or more alternative names to a dataclass field that should be used instead of the field's name in the code.</p> <p>Example:</p> <pre><code>import typing\nfrom dataclasses import dataclass\nfrom databind.core.settings import Alias\n\n@dataclass\nclass MyClass:\n  my_field: typing.Annotated[int, Alias('foobar', 'spam')]\n</code></pre> <p>When deserializing a payload, converters should now use <code>foobar</code> if it exists, or fall back to <code>spam</code> when looking   up the value for the field in the payload as opposed to <code>my_field</code>. When serializing, converters should use <code>foobar</code>   as the name in the generated payload (always the first alias).</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#aliases","title":"aliases","text":"<p>A tuple of the aliases provided to the constructor.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-required","title":"Class Required","text":"<pre><code>class Required(BooleanSetting)\n</code></pre> <p>[view_source]</p> <p>Indicates whether a field is required during deserialization, even if it's type specifies that it is an optional field.</p> <p>Example:</p> <pre><code>import typing\nfrom dataclasses import dataclass\nfrom databind.core.settings import Required\n\n@dataclass\nclass MyClass:\n  my_field: typing.Annotated[typing.Optional[int], Required()]\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-flattened","title":"Class Flattened","text":"<pre><code>class Flattened(BooleanSetting)\n</code></pre> <p>[view_source]</p> <p>Indicates whether a field should be \"flattened\" by virtually expanding it's sub fields into the parent datastructure's serialized form.</p> <p>Example:</p> <pre><code>import typing\nfrom dataclasses import dataclass\nfrom databind.core.settings import Flattened\n\n@dataclass\nclass Inner:\n  a: int\n  b: str\n\n@dataclass\nclass Outter:\n  inner: typing.Annotated[Inner, Flattened()]\n  c: str\n</code></pre> <p>The <code>Outter</code> class in the example above may be deserialized, for example, from a JSON payload of the form - <code>`{\"a\"</code> - 0, \"b\": \"\", \"c\": \"\"}<code>as opposed to</code>, \"c\": \"\"}<code>due to the</code>Outter.inner<code>field's sub fields being expanded into</code>Outter`.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-strict","title":"Class Strict","text":"<pre><code>class Strict(BooleanSetting)\n</code></pre> <p>[view_source]</p> <p>Enable strict conversion of the field during conversion (this should be the default for converters unless some maybe available option to affect the strictness in a converter is changed). This setting should particularly affect only loss-less type conversions (such as <code>int</code> to <code>string</code> and the reverse being allowed when strict handling is disabled).</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-serializedefaults","title":"Class SerializeDefaults","text":"<pre><code>class SerializeDefaults(BooleanSetting)\n</code></pre> <p>[view_source]</p> <p>Control whether default values are to be encoded in the serialized form of a structure. The default behaviour is up to the serializer implementation, though we consider it good practices to include values that match the default value of a field by default. However, using the setting defaults to <code>enabled</code> having a value of <code>True</code> due to how the name of the setting appears assertive of the fact that the instance indicates the setting is enabled.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-precision","title":"Class Precision","text":"<pre><code>@dataclasses.dataclass\nclass Precision(Setting)\n</code></pre> <p>[view_source]</p> <p>A setting to describe the precision for <code>decimal.Decimal</code> fields.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-union","title":"Class Union","text":"<pre><code>@dataclasses.dataclass\nclass Union(ClassDecoratorSetting)\n</code></pre> <p>[view_source]</p> <p>A setting that decorates a class or can be attached to the <code>typing.Annotated</code> metadata of a <code>typing.Union</code> type hint to specify that the type should be regarded as a union of more than one types. Which concrete type is to be used at the point of deserialization is usually clarified through a discriminator key. Unions may be of various styles that dictate how the discriminator key and the remaining fields are to be stored or read from.</p> <p>For serialiazation, the type of the Python value should inform the converter about which member of the union is being used. If the a union definition has multiple type IDs mapping to the same Python type, the behaviour is entirely up to the converter (an adequate resolution may be to pick the first matching type ID and ignore the remaining matches).</p> <p>Note</p> <p>The the examples for the different styles below, <code>\"type\"</code> is a stand-in for the value of the discriminator_key and <code>...</code> serves as a stand-in for the remaining fields of the type that is represented by the discriminator.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#nested","title":"NESTED","text":"<p>The nested style in JSON equivalent is best described as <code>{\"type\": \"&lt;typeid&gt;\", \"&lt;typeid&gt;\": { ... }}</code>.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#flat","title":"FLAT","text":"<p>The flat style in JSON equivalent is best described as <code>{\"type\": \"&lt;typeid&gt;\", ... }</code>.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#keyed","title":"KEYED","text":"<p>The keyed style in JSON equivalent is best described as <code>{\"&lt;typeid&gt;\": { ... }}</code>.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#best_match","title":"BEST_MATCH","text":"<p>The \"best match\" style attempts to deserialize the payload in an implementation-defined order and return the first or best succeeding result. No discriminator key is used.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#members","title":"members","text":"<p>The subtypes of the union as an implementation of the UnionMembers interface. When constructing the Union setting, a dictionary may be passed in place of a UnionMembers implementation, or a list of UnionMembers to chain them together. Te constructor will also accept a string that is either <code>\"&lt;import&gt;\"</code>, which will be converted to an ImportUnionMembers handler, or a string formatted as <code>\"!&lt;entrypoint&gt;\"</code>, which will be converted to an EntrypointUnionMembers handler.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#style","title":"style","text":"<p>The style of the union. This should be one of NESTED, FLAT, KEYED or BEST_MATCH. The default is NESTED.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#discriminator_key","title":"discriminator_key","text":"<p>The discriminator key to use, if valid for the style. Defaults to <code>\"type\"</code>.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#nesting_key","title":"nesting_key","text":"<p>The key to use when looking up the fields for the member type. Only used with the NESTED style. If not set, the union member's type ID is used as the key.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#register","title":"register","text":"<pre><code>@staticmethod\ndef register(\n        extends: type,\n        name: t.Optional[str] = None) -&gt; t.Callable[[t.Type[T]], t.Type[T]]\n</code></pre> <p>[view_source]</p> <p>A convenience method to use as a decorator for classes that should be registered as members of a Union setting that is attached to the type extends. The Union setting on extends must have a StaticUnionMembers members object. The decorated class must also be a subclass of extends.</p> <p>Example:</p> <pre><code>import abc\nimport dataclasses\nfrom databind.core.settings import Union\n\n@Union()\nclass MyInterface(abc.ABC):\n  # ...\n  pass\n\n@dataclasses.dataclass\n@Union.register(MyInterface, 'some')\nclass SomeImplementation(MyInterface):\n  # ...\n  pass\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-dateformat","title":"Class DateFormat","text":"<pre><code>@dataclasses.dataclass\nclass DateFormat(Setting)\n</code></pre> <p>[view_source]</p> <p>The DateFormat setting is used to describe the date format to use for <code>datetime.datetime</code>, <code>datetime.date</code> and <code>datetime.time</code> values when formatting them as a string, i.e. usually when the date/time is serialized, and when parsing them.</p> <p>The <code>nr.date</code> module provides types to describe the format of a date, time and datetime (see <code>date_format</code>, <code>time_format</code> and <code>datetime_format</code>), as well as an entire suite of formats for all types of date/time values.</p> <p>Arguments:</p> <ul> <li> <p><code>formats</code> - One or more datetime formats to use when parsing. The first of the formats is used for formatting.   Each element must be one of the following:</p> </li> <li> <p>A formatter (like <code>date_format</code>, <code>time_format</code> or <code>datetime_format</code>),</p> </li> <li>a <code>format_set</code>,</li> <li>a string that is a date/time format, or</li> <li>a string starting with a period (<code>.</code>) that names a builtin format set (like <code>.ISO_8601</code>)</li> </ul> <p>Attempting to use parse() or format() for a date/time value type for which the DateFormat does not   provide an applicable format results in a <code>ValueError</code>.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#parse","title":"parse","text":"<pre><code>def parse(type_: t.Type[T_Dtype], value: str) -&gt; T_Dtype\n</code></pre> <p>[view_source]</p> <p>Parse a date/time value from a string.</p> <p>Arguments:</p> <ul> <li><code>type_</code> - The type to parse the value into, i.e. <code>datetime.date</code>, <code>datetime.time</code> or <code>datetime.datetime</code>.</li> <li><code>value</code> - The string to parse.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If no date format is sufficient to parse value into the given type_.</li> </ul> <p>Returns:</p> <p>The parsed date/time value.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#format","title":"format","text":"<pre><code>def format(dt: T_Dtype) -&gt; str\n</code></pre> <p>[view_source]</p> <p>Format a date/time value to a string.</p> <p>Arguments:</p> <ul> <li><code>value</code> - The date/time value to format (i.e. an instance of <code>datetime.date</code>, <code>datetime.time</code> or   <code>datetime.datetime</code>).</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If no date format to format the type of value is available.</li> </ul> <p>Returns:</p> <p>The formatted date/time value.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-extrakeys","title":"Class ExtraKeys","text":"<pre><code>class ExtraKeys(ClassDecoratorSetting)\n</code></pre> <p>[view_source]</p> <p>If discovered while deserializing a <code>databind.core.schema.Schema</code>, it's callback is used to inform when extras keys are encountered. If the setting is not available, or if the arg is set to <code>False</code> (the default), it will cause an error.</p> <p>The setting may also be supplied at an individual schema level.</p> <p>Can be used as a decorator for a class to indicate that extra keys on the schema informed by the class are allowed, as a global setting or as an annotation on a schema field.</p> <p>Note</p> <p>Only the first, highest priority annotation is used; thus if you pass a callback for arg it may not be called if the ExtraKeys setting you pass it to is overruled by another.</p> <p></p> <p></p>"},{"location":"api/databind.core.settings/#class-remainder","title":"Class Remainder","text":"<pre><code>class Remainder(BooleanSetting)\n</code></pre> <p>[view_source]</p> <p>This setting can be used to indicate on a field of a schema that is of a mapping type that it consumes any extra keys that are not otherwise understood by the schema. Note that there can only be a maximum of 1 remainder field in the same schema.</p>"},{"location":"api/databind.core.union/","title":"databind.core.union","text":"<p>Provides the interface and implementations for representing the members of a union type.</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#class-unionmembers","title":"Class UnionMembers","text":"<pre><code>class UnionMembers(abc.ABC)\n</code></pre> <p>[view_source]</p> <p>Interface for representing the members of a union type. It defines methods to look up member type details based on name and Python type hints.</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#get_type_id","title":"get_type_id","text":"<pre><code>@abc.abstractmethod\ndef get_type_id(type_: t.Any) -&gt; str\n</code></pre> <p>[view_source]</p> <p>Given a Python type, return the ID of the type among the union members.</p> <p>Arguments:</p> <ul> <li><code>type_</code> - The Python type to retrieve the ID for.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the type_ is not a member of the union.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.core.union/#get_type_by_id","title":"get_type_by_id","text":"<pre><code>@abc.abstractmethod\ndef get_type_by_id(type_id: str) -&gt; t.Any\n</code></pre> <p>[view_source]</p> <p>Given type ID, return the Python type associated with that ID among the union members.</p> <p>Arguments:</p> <ul> <li><code>type_id</code> - The ID of the type to retrieve.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the type_id is not an ID among the union members.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.core.union/#get_type_ids","title":"get_type_ids","text":"<pre><code>@abc.abstractmethod\ndef get_type_ids() -&gt; t.List[str]\n</code></pre> <p>[view_source]</p> <p>Returns:</p> <p>A list of the type names known to the union subtypes.</p> <p>Raises:</p> <ul> <li><code>NotImplementedError</code> - If the method not supported by this implementation.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.core.union/#class-staticunionmembers","title":"Class StaticUnionMembers","text":"<pre><code>@dataclasses.dataclass\nclass StaticUnionMembers(UnionMembers)\n</code></pre> <p>[view_source]</p> <p>An implementation of UnionMembers that reads statically from a dictionary. The dictionary can be altered subsequently, which is commonly done to explicitly register a member. The members dictionary values may contain Python types or type hints understood by databind converters, as well as functions that return these types of values to allow for deferred evaluation.</p> <p>Example:</p> <pre><code>from databind.core.union import StaticUnionMembers\n\nmembers = StaticUnionMembers()\n\n@members.register('my-type')\nclass MyType:\n  pass\n</code></pre> <p>The register() method is also exposed for your convenience on the Union settings type (see Union.register()).</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#members","title":"members","text":"<p>The member types dictionary.</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#class-entrypointunionmembers","title":"Class EntrypointUnionMembers","text":"<pre><code>@dataclasses.dataclass\nclass EntrypointUnionMembers(UnionMembers)\n</code></pre> <p>[view_source]</p> <p>An implementation of UnionMembers to treat the member type ID as a name for an entry in a entrypoint group.</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#class-importunionmembers","title":"Class ImportUnionMembers","text":"<pre><code>class ImportUnionMembers(UnionMembers)\n</code></pre> <p>[view_source]</p> <p>This UnionMembers subclass treats type IDs as fully qualified identifiers by which to import Python classes.</p> <p>This implementation does not support UnionMembers.get_type_ids().</p> <p></p> <p></p>"},{"location":"api/databind.core.union/#class-chainunionmembers","title":"Class ChainUnionMembers","text":"<pre><code>@dataclasses.dataclass\nclass ChainUnionMembers(UnionMembers)\n</code></pre> <p>[view_source]</p> <p>Chain multiple implementations of UnionMembers.</p>"},{"location":"api/databind.json.converters/","title":"databind.json.converters","text":""},{"location":"api/databind.json.converters/#class-anyconverter","title":"Class AnyConverter","text":"<pre><code>class AnyConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A converter for <code>typing.Any</code> and <code>object</code> typed values, which will return them unchanged in any case.</p> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-datetimeconverter","title":"Class DatetimeConverter","text":"<pre><code>class DatetimeConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A converter for <code>datetime.datetime</code>, <code>datetime.date</code> and <code>datetime.time</code> that represents the serialized form as strings formatted using the <code>nr.date</code> module. The converter respects the DateFormat setting.</p> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-decimalconverter","title":"Class DecimalConverter","text":"<pre><code>class DecimalConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A converter for <code>decimal.Decimal</code> values to and from JSON as strings.</p> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-enumconverter","title":"Class EnumConverter","text":"<pre><code>class EnumConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>JSON converter for enum values.</p> <p>Converts <code>enum.IntEnum</code> values to integers and <code>enum.Enum</code> values to strings. Note that combined integer flags are not supported and cannot be serializ</p> <p>Aliases on the type annotation of an enum field are considered as aliases for the field name to be used in the value's serialized form as opposed to its value name defined in code.</p> <p>Example:</p> <pre><code>import enum, typing\nfrom databind.core.settings import Alias\n\nclass Pet(enum.Enum):\n  CAT = enum.auto()\n  DOG = enum.auto()\n  LION: typing.Annotated[int, Alias('KITTY')] = enum.auto()\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-plaindatatypeconverter","title":"Class PlainDatatypeConverter","text":"<pre><code>class PlainDatatypeConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A converter for the plain datatypes <code>bool</code>, <code>bytes</code>, <code>int</code>, <code>str</code> and <code>float</code>.</p> <p>Arguments:</p> <ul> <li><code>direction</code> Direction - The direction in which to convert (serialize or deserialize).</li> <li><code>strict_by_default</code> bool - Whether to use strict type conversion on values by default if no other   information on strictness is given. This defaults to <code>True</code>. With strict conversion enabled,   loss-less type conversions are disabled (such as casting a string to an integer). Note that   serialization is always strict, only the deserialization is controlled with this option or   the Strict setting.</li> </ul> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-schemaconverter","title":"Class SchemaConverter","text":"<pre><code>class SchemaConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>Converter for type hints that can be adapter to a <code>databind.core.schema.Schema</code> object.</p> <p>This converter respects the following settings:</p> <ul> <li>Alias</li> <li>SerializeDefaults</li> </ul> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-stringifyconverter","title":"Class StringifyConverter","text":"<pre><code>class StringifyConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A useful helper converter that matches on a given type or its subclasses and converts them to a string for serialization and deserializes them from a string using the type's constructor.</p> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-unionconverter","title":"Class UnionConverter","text":"<pre><code>class UnionConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>Converter for union types. The following kinds of union types are supported:</p> <ul> <li>A <code>typing.Union</code> (represented as <code>UnionTypeHint</code>) instance, in which case the members are deserialized in the the Union.NESTED mode, using the class name as the discriminator keys.</li> </ul> <pre><code>AOrB = A | B   # ex.: {\"type\": \"A\", \"A\": {...}}\n</code></pre> <ul> <li>A <code>typing.Annotated</code> annotated with the Union setting (represented as <code>AnnotatedTypeHint</code>)</li> </ul> <pre><code>from databind.core.settings import Union\nAOrB = typing.Annotated[A | B, Union({'a': A, 'b': B}, Union.KEYED)]  # ex.: {\"a\": {...}}\n</code></pre> <ul> <li>A class that is decorated with the Union setting</li> </ul> <pre><code>import dataclasses\nfrom databind.core.settings import Union\n\n@Union(style=Union.FLAT)\nclass Base(abc.ABC):\npass\n\n@Union.register(Base, 'a')\n@dataclasses.dataclass\nclass A(Base):\npass\n\n# ...\n# ex.: {\"type\": \"a\", ...}\n</code></pre> <p>Note</p> <p>Note that the union members should be concrete types, not generic aliases, because the converter cannot check if an object is an instance of an alias. This is an implementation detail of the <code>databind.core.union.UnionMembers</code> implementations.</p> <p>More Examples:</p> <pre><code>import abc\nimport typing\nfrom databind.core.settings import Union\n\nAOrB = typing.Annotated[\n  typing.Union[A, B],\n  Union({'A': A, 'B': B}, Union.NESTED, 'uses', 'with')\n]\n\n@Union('!my.package.plugins')\nclass Plugin(abc.ABC):\n  @abc.abstractmethod\n  def activate(self) -&gt; None: ...\n</code></pre> <p></p> <p></p>"},{"location":"api/databind.json.converters/#class-literalconverter","title":"Class LiteralConverter","text":"<pre><code>class LiteralConverter(Converter)\n</code></pre> <p>[view_source]</p> <p>A converter for <code>typing.Literal</code> type hints. A literal value in the definition must simply match the literal value in the context being serialized/deserialized, otherwise a ConversionError is raised. Currently, literal values must be of a plain data type that natively maps to a JSON type, like a boolean, integer, float, string or <code>None</code>.</p>"},{"location":"api/databind.json.direction/","title":"databind.json.direction","text":"<p>@pydoc databind.json.direction</p>"},{"location":"api/databind.json/","title":"databind.json","text":"<p>The <code>databind.json</code> package implements the capabilities to bind JSON payloads to objects and the reverse.</p>"},{"location":"api/databind.json.module/","title":"databind.json.module","text":""},{"location":"api/databind.json.module/#class-jsonmodule","title":"Class JsonModule","text":"<pre><code>class JsonModule(Module)\n</code></pre> <p>[view_source]</p> <p>The JSON module combines all converters provided by the <code>databind.json</code> package in one usable module. The direction in which the converters should convert must be specified with the direction argument. Alternatively, use one of the convenience static methods <code>serializing()</code> and <code>deserializing()</code>.</p>"},{"location":"changelog/databind.core/","title":"databind.core","text":""},{"location":"changelog/databind.core/#unreleased","title":"Unreleased","text":"TypeDescriptionPRIssuesAuthor Feature  add `DelegateToClassmethodConverter` class42@NiklasRosenstein Feature  add `JsonConverter.using_classmethods()` method42@NiklasRosenstein Improvement  Removed restriction that would only permit keys of type `int|str|Root|None` in `Context.key`. This unlocks serializing keys in mappings of specialized types.42@NiklasRosenstein"},{"location":"changelog/databind.core/#424-2023-04-12","title":"4.2.4 (2023-04-12)","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed an issue where the source class of a fields type hint was not correctly propagated to the TypeHint API such that evaluating forward references that reference to a member on the same class level would fail to evaluate.41@NiklasRosenstein"},{"location":"changelog/databind.core/#423-2023-04-12","title":"4.2.3 (2023-04-12)","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed an issue where TypeVar parametrization was lost when converting a dataclass to a schema.39@NiklasRosenstein"},{"location":"changelog/databind.core/#422-2022-11-30","title":"4.2.2 (2022-11-30)","text":"TypeDescriptionPRIssuesAuthor Fix  fix type hint for `ClassDecoratorSetting.__call__()` which would confuse Pylance34@NiklasRosenstein"},{"location":"changelog/databind.core/#420-2022-11-21","title":"4.2.0 (2022-11-21)","text":"TypeDescriptionPRIssuesAuthor Improvement  improve error message display format and add a default implementation for `Converter.__repr__()`@NiklasRosenstein Improvement  when a `ConversionError` occurs, we continue with the remaining converters to attempt to convert it until we are all out of options@NiklasRosenstein"},{"location":"changelog/databind.core/#411-2022-11-11","title":"4.1.1 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Feature  add `Module.register(first)` argument@NiklasRosenstein"},{"location":"changelog/databind.core/#410-2022-11-10","title":"4.1.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Tests  add a unnit test to see if the conversion of nested dataclasses with forward references works as expected (breaks in Python 3.6.2)@NiklasRosenstein Fix  Set min version to 3.6.3 because of a `typing.get_type_hints()` incompatibiltiy@NiklasRosenstein"},{"location":"changelog/databind.core/#400-2022-11-06","title":"4.0.0 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Databind is now compatible with Python 3.6! This required a few breaking changes to the API used to extend Databind, which is why this is a major version bump. We now use `typeapi 1.x` which has a significantly different API but enables the Python 3.6 compatibilty.31@NiklasRosenstein"},{"location":"changelog/databind.core/#300-2022-11-05","title":"3.0.0 (2022-11-05)","text":"TypeDescriptionPRIssuesAuthor Breaking change  add `Direction` as a concept to `databind.core` (previously only in `databind.json`) which can be imported from `databind.core.context`@NiklasRosenstein Feature  add `Context.direction` member@NiklasRosenstein Feature  add `ObjectMapper.serialize()` and `ObjectMapper.deserialize()`@NiklasRosenstein Breaking change  remove `BiObjectMapper` class@NiklasRosenstein Breaking change  add `direction` argument to `ObjectMapper.convert()`@NiklasRosenstein Feature  add `Converter.serialize()` and `Converter.deserialize()`, add default implementation for `Converter.convert()` to dispatch to the respective member based on the `Context.direction`@NiklasRosenstein Breaking change  `ObjectMapper` is now a generic with parameters `T` (the deserialized representation of the type) and `U` (the serialized representation of the type)@NiklasRosenstein Breaking change  Change `ExtraKeys` setting signature from `(arg: bool | callable)` to `(allow: bool = True, recorder: callable | None = None)`@NiklasRosenstein"},{"location":"changelog/databind.core/#209-2022-11-03","title":"2.0.9 (2022-11-03)","text":"TypeDescriptionPRIssuesAuthor Feature  add `Module.get_converters()`@NiklasRosenstein"},{"location":"changelog/databind.core/#207-2022-06-20","title":"2.0.7 (2022-06-20)","text":"TypeDescriptionPRIssuesAuthor Improvement  Enable Mypy strict type checking mode@NiklasRosenstein"},{"location":"changelog/databind.core/#206-2022-06-20","title":"2.0.6 (2022-06-20)","text":"TypeDescriptionPRIssuesAuthor Improvement  Add support for `typeapi 0.2.0`@NiklasRosenstein"},{"location":"changelog/databind.core/#204-2022-05-11","title":"2.0.4 (2022-05-11)","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed an issue where the frame for a dataclass type saved with `typeapi.scoped` was not respected for type evaluation.@NiklasRosenstein Fix  Fixed module-scoped evaluation of forward references for subclasses of `typing.TypedDict`.@NiklasRosenstein"},{"location":"changelog/databind.core/#203-2022-05-11","title":"2.0.3 (2022-05-11)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix resolving nested forward references in dataclasses.@NiklasRosenstein"},{"location":"changelog/databind.core/#202-2022-05-11","title":"2.0.2 (2022-05-11)","text":"TypeDescriptionPRIssuesAuthor Docs  Add URLs to project metadata.@NiklasRosenstein Improvement  Schemas (dataclasses, typed dicts) that have an `Optional` field that are not explicitly marked as `Required()` now automatically get assigned `None` as a default value@NiklasRosenstein"},{"location":"changelog/databind.core/#201-2022-05-09","title":"2.0.1 (2022-05-09)","text":"TypeDescriptionPRIssuesAuthor Improvement  Loosen requirement on `typing-extensions` from `^3.10.0` to `&gt;=3.10.0`@NiklasRosenstein Refactor  Use Black and isort for code formatting, Flake8 for linting@NiklasRosenstein"},{"location":"changelog/databind.core/#200-alpha4-2022-03-29","title":"2.0.0-alpha.4 (2022-03-29)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix error in `ConversionError.expected()` if the `types` parameter was a type hint@NiklasRosenstein Breaking change  add `ConversionError()` `origin` and `errors` parameter@NiklasRosenstein"},{"location":"changelog/databind.core/#200a2-2022-03-24","title":"2.0.0a2 (2022-03-24)","text":"TypeDescriptionPRIssuesAuthor Improvement  move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core`@NiklasRosenstein Feature  make `ExtraKeys` setting a subclass of `ClassDecoratorSetting`, allowing it to be used to mark an entire class and allowing extra keys@NiklasRosenstein"},{"location":"changelog/databind.core/#152-2022-03-23","title":"1.5.2 (2022-03-23)","text":"TypeDescriptionPRIssuesAuthor Feature  add `nesting_key` parameter to `union()` annotation@NiklasRosenstein"},{"location":"changelog/databind.core/#151-2022-02-26","title":"1.5.1 (2022-02-26)","text":"TypeDescriptionPRIssuesAuthor Refactor  migrate to `nr.util` package@NiklasRosenstein"},{"location":"changelog/databind.core/#150-2022-02-26","title":"1.5.0 (2022-02-26)","text":"TypeDescriptionPRIssuesAuthor Feature  support resolution of type variables as they are encountered in unspecialized formNiklasRosenstein/databind#25@NiklasRosenstein Fix  fix `unpack_type_hints()` to return args for a parametrized special generic alias (like `typing.List[T]` returning `(list, (T,))`)@NiklasRosenstein"},{"location":"changelog/databind.core/#140-2022-01-22","title":"1.4.0 (2022-01-22)","text":"TypeDescriptionPRIssuesAuthor Feature  add `union.Style.keyed`NiklasRosenstein/databind#21@NiklasRosenstein"},{"location":"changelog/databind.core/#132-2022-01-10","title":"1.3.2 (2022-01-10)","text":"TypeDescriptionPRIssuesAuthor Fix  make `databind.core.annotations` hashable for use in `typing.Annotations`@NiklasRosenstein"},{"location":"changelog/databind.core/#131-2022-01-08","title":"1.3.1 (2022-01-08)","text":"TypeDescriptionPRIssuesAuthor Fix  Dataclass adapted to ObjectType with no schema fields if a field cannot be adaptedNiklasRosenstein/databind#23@NiklasRosenstein Feature  support resolving forward references in PEP585 generic aliasesNiklasRosenstein/databind#24@NiklasRosenstein Improvement  change `ConverterProvider.get_converter()` to `ConverterProvider.get_converters()` and `ConversionNotApplicable` error type, allowing to test multiple converters for a type@NiklasRosenstein"},{"location":"changelog/databind.core/#130-2022-01-06","title":"1.3.0 (2022-01-06)","text":"TypeDescriptionPRIssuesAuthor Improvement  improve readability of `ConversionError` by changing `Location.format()`@NiklasRosenstein"},{"location":"changelog/databind.core/#126-2021-12-29","title":"1.2.6 (2021-12-29)","text":"TypeDescriptionPRIssuesAuthor Fix  correctly support Python 3.10 `types.UnionType`@NiklasRosenstein"},{"location":"changelog/databind.core/#125-2021-10-24","title":"1.2.5 (2021-10-24)","text":"TypeDescriptionPRIssuesAuthor Fix  add missing nr.pylang.utils dependency (was introduced transtively before so it was no crucial bug)@NiklasRosenstein"},{"location":"changelog/databind.core/#123-2021-09-06","title":"1.2.3 (2021-09-06)","text":"TypeDescriptionPRIssuesAuthor Fix  allow datetime objects as value during deserializationNiklasRosenstein/databind#19@NiklasRosenstein"},{"location":"changelog/databind.core/#122-2021-09-01","title":"1.2.2 (2021-09-01)","text":"TypeDescriptionPRIssuesAuthor Fix  `DefaultTypeHintAdapter` no longer raises an exception upon receiving a BaseType instance@NiklasRosenstein Improvement  `dataclass_to_schema(type_adapter)` argument is now optional and defaults to a `DefaultTypeHintAdapter` instance@NiklasRosenstein"},{"location":"changelog/databind.core/#120-2021-08-20","title":"1.2.0 (2021-08-20)","text":"TypeDescriptionPRIssuesAuthor Feature  add `Direction.is_serialize()` and `Direction.is_deserialize()`@NiklasRosenstein Feature  add `AnnotationsRegistry.add_type_annotation()` and `AnnotationsRegistry.add_field_annotation()`@NiklasRosenstein Feature  `DefaultAnnotationsProvider` now supports finding annotations in `Enum` members when annotated with `te.Annotated`, `DefaultAnnotationsProvider` is now registered to an `ObjectMapper` by default@NiklasRosenstein"},{"location":"changelog/databind.core/#116-2021-08-18","title":"1.1.6 (2021-08-18)","text":"TypeDescriptionPRIssuesAuthor Fix  fix case where DefaultTypeHintAdapter does not continue adaptation dynamically upon encountering a fixed type object@NiklasRosenstein"},{"location":"changelog/databind.core/#115-2021-08-16","title":"1.1.5 (2021-08-16)","text":"TypeDescriptionPRIssuesAuthor Fix  normal type with `Annotated[MyType, union(...)]` is now correctly interpreted as `UnionType`@NiklasRosenstein"},{"location":"changelog/databind.core/#113-2021-08-10","title":"1.1.3 (2021-08-10)","text":"TypeDescriptionPRIssuesAuthor Improvement  `ObjectType` and `ConcreteType` now show the class fqn on repr()@NiklasRosenstein Fix  fix support for special generic subclasses (like `List` or `Dict`) with another generic base class (eg. `Generic`)@NiklasRosenstein"},{"location":"changelog/databind.core/#112-2021-08-06","title":"1.1.2 (2021-08-06)","text":"TypeDescriptionPRIssuesAuthor Fix  fix `@A.union` types to accept `ObjectType`s@NiklasRosenstein"},{"location":"changelog/databind.core/#111-2021-08-03","title":"1.1.1 (2021-08-03)","text":"TypeDescriptionPRIssuesAuthor Fix  fix `EntrypointSubtypes()` constructor which used to accidentally accept a `TypeHintAdapter` argument@NiklasRosenstein"},{"location":"changelog/databind.core/#110-2021-08-03","title":"1.1.0 (2021-08-03)","text":"TypeDescriptionPRIssuesAuthor Improvement  remove `AnnotatedType`, add `BaseType.annotations` instead.@NiklasRosenstein Breaking change  Reorganize a lot of internal APIs and some public APIs (e.g. renamed `ITypeHintConverter` to `TypeHintAdapter`, `IConverter` to `Converter` + respective module name changes, deprecated `ObjectMapper.default()`, remove `IObjectMapper` and replace `Context.mapper` with `Context.converters` and `Context.annotations`.@NiklasRosenstein Breaking change  replace `Schema.flat_fields()` with `Schema.flattened()`@NiklasRosenstein Improvement  only import members from sub-modules where they are expected to be used from (ie. `databind.core`, `databind.core.annotations`, `databind.core.dataclasses`, `databind.json`)@NiklasRosenstein Feature  add support for `fieldinfo(flat=True)` marked `MapType` fieldsNiklasRosenstein/databind#7@NiklasRosenstein"},{"location":"changelog/databind.core/#101-2021-07-23","title":"1.0.1 (2021-07-23)","text":"TypeDescriptionPRIssuesAuthor Improvement  import `dataclass_to_schema` into `databind.core` top-level package@NiklasRosenstein Fix  fix type hints to pass mypy checks@NiklasRosenstein"},{"location":"changelog/databind.core/#100-2021-07-20","title":"1.0.0 (2021-07-20)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Full rewrite@NiklasRosenstein"},{"location":"changelog/databind.core/#0110-2021-04-08","title":"0.11.0 (2021-04-08)","text":"TypeDescriptionPRIssuesAuthor Feature  `enumerate_fields()` now works with uniontype instances and classes@NiklasRosenstein Improvement  update `@uniontype` generated `__repr__()` method@NiklasRosenstein Feature  add support for member aliasing in `UnionResolver`@NiklasRosenstein Feature  add `Context.closed_field_metadata()` function@NiklasRosenstein"},{"location":"changelog/databind.core/#0100-2021-03-05","title":"0.10.0 (2021-03-05)","text":"TypeDescriptionPRIssuesAuthor Improvement  classes decorated with `@uniontype(container=True)` must now be constructed using a single keyword argument as in `MyUnion(member1=Member1Value())` @NiklasRosenstein"},{"location":"changelog/databind.core/#090-2020-12-30","title":"0.9.0 (2020-12-30)","text":"TypeDescriptionPRIssuesAuthor Feature  add `ImportingUnionResolver` and `EntrypointUnionResolver`, both which can also be used with the `@interface` decorator. The `resolver` argument now accepts a string which will be converted into a `UnionResolver` (supported formats are `import` and `entrypoint:`)@NiklasRosenstein Fix  `@implementation()` can now be used without explicitly specifying the `for_` parameter when decorating a class with multiple bases where only one base is a `@uniontype`@NiklasRosenstein Fix  fix inheritance of fields from `@dataclass` parent classes@NiklasRosenstein"},{"location":"changelog/databind.core/#080-2020-11-24","title":"0.8.0 (2020-11-24)","text":"TypeDescriptionPRIssuesAuthor Improvement  `@implementation()` now sets the databind metadata field to `None` if no explicit metadata is already set on the type. `Registry.get_converter()` recognizes this case and stops checking the base classes. This is to avoid a confusing error when the type decorated with `@implementation()` seems to inherit the `UnionMetadata` from the parent class (because of the `Registry.get_converter()` base class check) but actually does not provide a metadata. Now we see \"no converter found for type XYZ\" instead \"expected UnionMetadata to be provided by XYZ\" in `databind.json`@NiklasRosenstein"},{"location":"changelog/databind.core/#071-2020-11-20","title":"0.7.1 (2020-11-20)","text":"TypeDescriptionPRIssuesAuthor Fix  Python 3.9 support in type hint normalization@NiklasRosenstein Fix  fix mypy errors@NiklasRosenstein"},{"location":"changelog/databind.core/#070-2020-10-02","title":"0.7.0 (2020-10-02)","text":"TypeDescriptionPRIssuesAuthor Feature  `@dataclasses.dataclass()` classes can now be converted as a data model automatically, `BaseMetadata.for_type()` now returns an optional@NiklasRosenstein"},{"location":"changelog/databind.core/#060-2020-09-14","title":"0.6.0 (2020-09-14)","text":"TypeDescriptionPRIssuesAuthor Fix  `Registry.get_converter()` now looks for a converter in the base classes only if it could not find it for the normalized version of the current type, making converter resolution more predictable@NiklasRosenstein Feature  Add `ClassUnionResolver` which evaluates type hints dynamically, allowing to use forward references in the type hints of a `@uniontype()`@NiklasRosenstein Feature  Add `@interface()` and `@implementation()` decorators@NiklasRosenstein"},{"location":"changelog/databind.core/#050-2020-09-10","title":"0.5.0 (2020-09-10)","text":"TypeDescriptionPRIssuesAuthor"},{"location":"changelog/databind.core/#042-2020-09-09","title":"0.4.2 (2020-09-09)","text":"TypeDescriptionPRIssuesAuthor Hygiene  Move `type_repr()` declaration to `databind.core.utils` and add `find_orig_base()` function@NiklasRosenstein"},{"location":"changelog/databind.core/#041-2020-09-08","title":"0.4.1 (2020-09-08)","text":"TypeDescriptionPRIssuesAuthor Fix  Re-render setup file, materializing missing dependency on `dataclasses`. This fixes using the module in Python 3.6.@NiklasRosenstein"},{"location":"changelog/databind.core/#040-2020-09-06","title":"0.4.0 (2020-09-06)","text":"TypeDescriptionPRIssuesAuthor Feature  add `ModelMetadata.serialize_as` (which translates into a keyword argument for `@datamodel()`) to specify a type hint that should be used instead of the type itself when serializing/deserializing it@NiklasRosenstein Feature  add `Context.coerce_errors()` context manager@NiklasRosenstein Feature  add `TypeHint` variable which should be used in places where a type hint is expected@NiklasRosenstein"},{"location":"changelog/databind.core/#030-2020-08-29","title":"0.3.0 (2020-08-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  ensure that non-default arguments do not have a class attribute of type `object` (which is used as a workaround to support non-default fields following default fields in `dataclasses`)@NiklasRosenstein Fix  raise for uninitialized fields inherited from parent datamodels@NiklasRosenstein"},{"location":"changelog/databind.core/#020-2020-08-29","title":"0.2.0 (2020-08-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  update type hints to pass mypy checks@NiklasRosenstein Improvement  `FieldMetadata` now keeps a reference to the `dataclasses.Field` object and it's' metadata@NiklasRosenstein"},{"location":"changelog/databind.json/","title":"databind.json","text":""},{"location":"changelog/databind.json/#421-2022-11-21","title":"4.2.1 (2022-11-21)","text":"TypeDescriptionPRIssuesAuthor Improvement  add `StringifyConverter(name)` parameter and improve `__repr__()`@NiklasRosenstein Fix  fix order of converters for `pathlib.Path` and `pathlib.PurePath` registered to the `JsonModule`@NiklasRosenstein"},{"location":"changelog/databind.json/#420-2022-11-21","title":"4.2.0 (2022-11-21)","text":"TypeDescriptionPRIssuesAuthor Tests  add unit tests for deserializing `duration` from an object form@NiklasRosenstein Docs  update readme to list supported types@NiklasRosenstein"},{"location":"changelog/databind.json/#411-2022-11-11","title":"4.1.1 (2022-11-11)","text":"TypeDescriptionPRIssuesAuthor Fix  Register stringify converters for specific types first in the module to take priority over other converters (fixes deserializing `nr.date.duration`)@NiklasRosenstein"},{"location":"changelog/databind.json/#410-2022-11-10","title":"4.1.0 (2022-11-10)","text":"TypeDescriptionPRIssuesAuthor Fix  Set min version to 3.6.3 because of a `typing.get_type_hints()` incompatibiltiy@NiklasRosenstein Feature  support deserialization of tuples@NiklasRosenstein"},{"location":"changelog/databind.json/#400-2022-11-06","title":"4.0.0 (2022-11-06)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Databind is now compatible with Python 3.6! This required a few breaking changes to the API used to extend Databind, which is why this is a major version bump. We now use `typeapi 1.x` which has a significantly different API but enables the Python 3.6 compatibilty.31@NiklasRosenstein"},{"location":"changelog/databind.json/#300-2022-11-05","title":"3.0.0 (2022-11-05)","text":"TypeDescriptionPRIssuesAuthor Docs  add Examples page to docs@NiklasRosenstein Breaking change  remove `get_bimapper()` and replace it with `get_object_mapper()`@NiklasRosenstein Breaking change  remove `Direction` concept from this package as it is now part of `databind.core`, removed it from `JsonModule` and all `Converter` implementations@NiklasRosenstein"},{"location":"changelog/databind.json/#209-2022-11-03","title":"2.0.9 (2022-11-03)","text":"TypeDescriptionPRIssuesAuthor Feature  add `JsonConverter()` setting to override the converter used for JSON de-/serialization@NiklasRosenstein"},{"location":"changelog/databind.json/#208-2022-09-27","title":"2.0.8 (2022-09-27)","text":"TypeDescriptionPRIssuesAuthor Improvement  Add a `LiteralConverter` which allows you to create literal-based unions (see new example in readme)@NiklasRosenstein"},{"location":"changelog/databind.json/#207-2022-06-20","title":"2.0.7 (2022-06-20)","text":"TypeDescriptionPRIssuesAuthor Improvement  Enable Mypy strict type checking mode@NiklasRosenstein"},{"location":"changelog/databind.json/#205-2022-06-16","title":"2.0.5 (2022-06-16)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix that subclasses of a dataclasses marked also with @Union are deserialized as dataclasses instead of Unions; this change may have wider reaching effects because we no longer look up settings in bases of a type, but unit tests are OK with this@NiklasRosenstein"},{"location":"changelog/databind.json/#203-2022-05-11","title":"2.0.3 (2022-05-11)","text":"TypeDescriptionPRIssuesAuthor Fix  Fixed an issue when deserializing fields in a schema when the Python type does not have the exact same representation in the structured payload, causing an error when that Python default value is handed as a value to be deserialized.@NiklasRosenstein"},{"location":"changelog/databind.json/#202-2022-05-11","title":"2.0.2 (2022-05-11)","text":"TypeDescriptionPRIssuesAuthor Docs  Add URLs to project metadata.@NiklasRosenstein Improvement  Use a fields default value if it is available when deserializing schemas@NiklasRosenstein"},{"location":"changelog/databind.json/#201-2022-05-09","title":"2.0.1 (2022-05-09)","text":"TypeDescriptionPRIssuesAuthor Improvement  Loosen requirement on `typing-extensions` from `^3.10.0` to `&gt;=3.10.0`@NiklasRosenstein Refactor  Use Black and isort for code formatting, Flake8 for linting@NiklasRosenstein"},{"location":"changelog/databind.json/#200-2022-03-31","title":"2.0.0 (2022-03-31)","text":"TypeDescriptionPRIssuesAuthor Breaking change  Remove `databind.json.settings` module@NiklasRosenstein"},{"location":"changelog/databind.json/#200-alpha4-2022-03-29","title":"2.0.0-alpha.4 (2022-03-29)","text":"TypeDescriptionPRIssuesAuthor Breaking change  implement `Union.BEST_MATCH` in `UnionConverter`, which is now used as the default if an un-annotated `typing.Union` is encountered@NiklasRosenstein"},{"location":"changelog/databind.json/#200a3-2022-03-29","title":"2.0.0a3 (2022-03-29)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix `CollectionConverter` (used for subclasses of `collections.abc.Collection`) does not end up returnin a generator instead of a collection@NiklasRosenstein"},{"location":"changelog/databind.json/#200a2-2022-03-24","title":"2.0.0a2 (2022-03-24)","text":"TypeDescriptionPRIssuesAuthor Improvement  move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core`@NiklasRosenstein"},{"location":"changelog/databind.json/#151-2022-02-26","title":"1.5.1 (2022-02-26)","text":"TypeDescriptionPRIssuesAuthor Refactor  migrate to `nr.util` package@NiklasRosenstein"},{"location":"changelog/databind.json/#140-2022-01-22","title":"1.4.0 (2022-01-22)","text":"TypeDescriptionPRIssuesAuthor Feature  support `union.Style.keyed`NiklasRosenstein/databind#21@NiklasRosenstein"},{"location":"changelog/databind.json/#131-2022-01-08","title":"1.3.1 (2022-01-08)","text":"TypeDescriptionPRIssuesAuthor Feature  add `databind.json.annotations.with_custom_json_converter()` annotation to allow implementing a custom converter for dataclasses@NiklasRosenstein Fix  narrow `JsonType` union type to use `dict` and `list` instead of `t.Mapping` and `t.Collection`NiklasRosenstein/databind#22@NiklasRosenstein"},{"location":"changelog/databind.json/#124-2021-10-24","title":"1.2.4 (2021-10-24)","text":"TypeDescriptionPRIssuesAuthor Fix  declare missing `nr.optional` dependency (was not an actual bug because the dependency was introduced transitively anyway)@NiklasRosenstein"},{"location":"changelog/databind.json/#120-2021-08-20","title":"1.2.0 (2021-08-20)","text":"TypeDescriptionPRIssuesAuthor Feature  add converter for `pathlib.PurePath` subclasses, enabled in the `JsonModule` by defaultNiklasRosenstein/databind#14@NiklasRosenstein Feature  add converter for `uuid.UUID` to `JsonModule`NiklasRosenstein/databind#15@NiklasRosenstein Feature  support aliases on enum valuesNiklasRosenstein/databind#1@NiklasRosenstein"},{"location":"changelog/databind.json/#115-2021-08-16","title":"1.1.5 (2021-08-16)","text":"TypeDescriptionPRIssuesAuthor Fix  `str`, `bytes`, `bytearray` and `memoryview` are no longer accepted when deserializing `CollectionType` valuesNiklasRosenstein/databind#13@NiklasRosenstein"},{"location":"changelog/databind.json/#112-2021-08-06","title":"1.1.2 (2021-08-06)","text":"TypeDescriptionPRIssuesAuthor Feature  support de-/serializing `bytes` as base64@NiklasRosenstein"},{"location":"changelog/databind.json/#0120-2021-04-08","title":"0.12.0 (2021-04-08)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `uniontype(single_key_discriminator)` argument@NiklasRosenstein Fix  Generated `__eq__()` method for `uniontype(container=True)` is now injective to avoid issue when `type(other)` is `object`@NiklasRosenstein Feature  add support for aliasing with `field(altname)` in `@uniontype` container declarations@NiklasRosenstein Feature  `StringConverter` can now also be relaxed, `FieldMetadata.relaxed` is now inherited from the closest metadata in the context for POD data types@NiklasRosenstein Fix  deserializing a `List[str]` from a `str` object now results in an error@NiklasRosenstein Improvement  bump dependency on databind.core to ^0.11.0@NiklasRosenstein"},{"location":"changelog/databind.json/#0110-2021-03-05","title":"0.11.0 (2021-03-05)","text":"TypeDescriptionPRIssuesAuthor Improvement  Update union construction during deserialization@NiklasRosenstein Improvement  minimum version of `databind.core` is `^0.10.0`@NiklasRosenstein"},{"location":"changelog/databind.json/#0100-2020-12-30","title":"0.10.0 (2020-12-30)","text":"TypeDescriptionPRIssuesAuthor Fix  add missing `to_stream` and `from_stream` to `__all__`@NiklasRosenstein Feature  add `cast()` function@NiklasRosenstein"},{"location":"changelog/databind.json/#090-2020-11-24","title":"0.9.0 (2020-11-24)","text":"TypeDescriptionPRIssuesAuthor Feature  handle `FieldMetadata.relaxed` and `FieldMetadata.strict` in Bool, Integer and String converters@NiklasRosenstein"},{"location":"changelog/databind.json/#080-2020-11-24","title":"0.8.0 (2020-11-24)","text":"TypeDescriptionPRIssuesAuthor Feature  add converter for `typing.Any`, which by the way does not actually convert anything@NiklasRosenstein"},{"location":"changelog/databind.json/#071-2020-11-20","title":"0.7.1 (2020-11-20)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix mypy errors@NiklasRosenstein"},{"location":"changelog/databind.json/#070-2020-10-02","title":"0.7.0 (2020-10-02)","text":"TypeDescriptionPRIssuesAuthor Feature  Now supports converting Sets@NiklasRosenstein"},{"location":"changelog/databind.json/#061-2020-09-10","title":"0.6.1 (2020-09-10)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix `NameError` in `ObjectConverter`@NiklasRosenstein"},{"location":"changelog/databind.json/#060-2020-09-10","title":"0.6.0 (2020-09-10)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `to_stream()` and `from_stream()` functions@NiklasRosenstein Feature  Add support for `typing.Dict` subclasses@NiklasRosenstein"},{"location":"changelog/databind.json/#051-2020-09-09","title":"0.5.1 (2020-09-09)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix Python 3.6 support for `typing.List` subclasses by reading the generic paraemter from the right object@NiklasRosenstein"},{"location":"changelog/databind.json/#050-2020-09-06","title":"0.5.0 (2020-09-06)","text":"TypeDescriptionPRIssuesAuthor Feature  Add `strict` argument to `register_json_converters()` which will allow converters for plain-old-datatypes to accept string representations as well@NiklasRosenstein"},{"location":"changelog/databind.json/#041-2020-09-06","title":"0.4.1 (2020-09-06)","text":"TypeDescriptionPRIssuesAuthor Fix  conversion of values of a `List` subtype *from Python* are now converted to a built-in `list` instead of the same `List` subtype@NiklasRosenstein"},{"location":"changelog/databind.json/#040-2020-09-06","title":"0.4.0 (2020-09-06)","text":"TypeDescriptionPRIssuesAuthor Feature  support `@datamodel(serialize_as)` in `ModelConverter`@NiklasRosenstein"},{"location":"changelog/databind.json/#030-2020-08-29","title":"0.3.0 (2020-08-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  `ArrayConverter` now supports subclasses of the `typing.List` generic@NiklasRosenstein"},{"location":"changelog/databind.json/#020-2020-08-29","title":"0.2.0 (2020-08-29)","text":"TypeDescriptionPRIssuesAuthor Improvement  update type hints to pass mypy checks@NiklasRosenstein Improvement  add DEBUG log when `MixtypeConverter` is unable to convert a value at all to make debugging easier@NiklasRosenstein Fix  accept `datetime.date`/`datetime.datetime` objects when converting to python if the target type is a respective match (rather than forcing a string as an input)@NiklasRosenstein"}]}
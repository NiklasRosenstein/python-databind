{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"databind Databind is a library inspired by jackson-databind to de-/serialise Python dataclasses. The databind package will install the full suite of databind packages. Compatible with Python 3.7 and newer. databind.core \u2013 Provides the core framework. databind.json \u2013 De-/serialize dataclasses to/from JSON payloads. Supported features Feature Python version Databind version PEP585 3.9 1.2.0 \u2013 current PEP585 (forward references) 3.9 1.3.1? \u2013 current Resolve type parameters of specialised generic types 3.x 1.5.0 \u2013 current typing.TypedDict 3.x 2.0.0 \u2013 current Concretise type variables in parametrised generics 3.x 2.0.0 \u2013 current Copyright \u00a9 2022 \u2013 Niklas Rosenstein","title":"Home"},{"location":"#databind","text":"Databind is a library inspired by jackson-databind to de-/serialise Python dataclasses. The databind package will install the full suite of databind packages. Compatible with Python 3.7 and newer. databind.core \u2013 Provides the core framework. databind.json \u2013 De-/serialize dataclasses to/from JSON payloads.","title":"databind"},{"location":"#supported-features","text":"Feature Python version Databind version PEP585 3.9 1.2.0 \u2013 current PEP585 (forward references) 3.9 1.3.1? \u2013 current Resolve type parameters of specialised generic types 3.x 1.5.0 \u2013 current typing.TypedDict 3.x 2.0.0 \u2013 current Concretise type variables in parametrised generics 3.x 2.0.0 \u2013 current Copyright \u00a9 2022 \u2013 Niklas Rosenstein","title":"Supported features"},{"location":"databind.core/","text":"databind.core databind.core provides a jackson-databind inspired framework for data de-/serialization in Python. Unless you are looking to implement support for de-/serializing new data formats, the databind.core package alone might not be what you are looking for (unless you want to use databind.core.dataclasses as a drop-in replacement to the standard library dataclasses module, for that check out the section at the bottom). Known implementations databind.json Dataclass extension The standard library dataclasses module does not allow to define non-default arguments after default arguments. You can use databind.core.dataclasses as a drop-in replacement to get this feature. It behaves exactly like the standard library, only that non-default arguments may follow default arguments. Such arguments can be passed to the constructor as positional or keyword arguments. from databind.core import dataclasses @dataclasses . dataclass class A : value1 : int = 42 @dataclasses . dataclass class B ( A ): value2 : str print ( B ( 0 , 'Hello, World!' )) print ( B ( value2 = 'Answer to the universe' )) Copyright \u00a9 2020 \u2013 Niklas Rosenstein","title":"databind.core"},{"location":"databind.core/#databindcore","text":"databind.core provides a jackson-databind inspired framework for data de-/serialization in Python. Unless you are looking to implement support for de-/serializing new data formats, the databind.core package alone might not be what you are looking for (unless you want to use databind.core.dataclasses as a drop-in replacement to the standard library dataclasses module, for that check out the section at the bottom).","title":"databind.core"},{"location":"databind.core/#known-implementations","text":"databind.json","title":"Known implementations"},{"location":"databind.core/#dataclass-extension","text":"The standard library dataclasses module does not allow to define non-default arguments after default arguments. You can use databind.core.dataclasses as a drop-in replacement to get this feature. It behaves exactly like the standard library, only that non-default arguments may follow default arguments. Such arguments can be passed to the constructor as positional or keyword arguments. from databind.core import dataclasses @dataclasses . dataclass class A : value1 : int = 42 @dataclasses . dataclass class B ( A ): value2 : str print ( B ( 0 , 'Hello, World!' )) print ( B ( value2 = 'Answer to the universe' )) Copyright \u00a9 2020 \u2013 Niklas Rosenstein","title":"Dataclass extension"},{"location":"databind.json/","text":"databind.json The databind.json package implements the de-/serialization to or from JSON payloads using the databind.core framework. Check out the Documentation for examples. Copyright \u00a9 2020 \u2013 Niklas Rosenstein","title":"databind.json"},{"location":"databind.json/#databindjson","text":"The databind.json package implements the de-/serialization to or from JSON payloads using the databind.core framework. Check out the Documentation for examples. Copyright \u00a9 2020 \u2013 Niklas Rosenstein","title":"databind.json"},{"location":"examples/","text":"Examples This page shows some common usage examples for using the databind.json library. Configuration deserialization A common use case is to describe the configuration for an application as dataclasses, then deserialize it from a JSON, YAMl or TOML file. from __future__ import annotations import databind.json import dataclasses import tomlib from pathlib import Path @dataclasses . dataclass class ServerConfig : host : str port : int = 8080 @dataclasses . dataclass class MainConfig : server : ServerConfig @staticmethod def load ( path : Path | str ) -> MainConfig : data = tomlib . loads ( Path ( path ) . read_text ()) return databind . json . load ( data , MainConfig , filename = path ) config = MainConfig . load_toml ( \"config.toml\" ) An example config TOML file that can be parsed with the above configuration: [server] host = \"localhost\" port = 8080 Note that any extra keys that are not expected per the schema will raise a databind.core.converter.ConversionError . Danger Databind uses Python runtime type annotation introspection using the typeapi package. This requires that all type annotations that databind comes in contact with must be valid expressions in the current Python version, even if from __future__ import annotations is used. This means if your code needs to be compatible with Python versions lower than 3.10 or 3.9 that you can not use the new type union syntax ( a | b ) or built-in generic aliases (such as list[int] ) and need to continue to use typing.Union , typing.Optional and typing.List , etc. Permitting unknown keys If you would like to permit extra keys to to be present in a payload that is being deserialized without raising a databind.core.converter.ConversionError , you can use the databind.core.settings.ExtraKeys setting to annotate a @dataclass , an annotation or specify it globally to allow extra keys anywhere. When using this setting, you can also record any unexpected keys so you can report them after the deserialization. Allowing extra keys on a dataclass # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load @ExtraKeys () @dataclass class MyClass : a : int assert load ({ \"a\" : 42 , \"b\" : \"ignored\" }, MyClass ) == MyClass ( 42 ) Note The ExtraKeys setting does not apply transitively to the members of the dataclass. Allowing extra keys on a dataclass member # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load from typing_extensions import Annotated @dataclass class Sub : a : int @dataclass class Main : sub : Annotated [ Sub , ExtraKeys ()] assert load ({ \"sub\" : { \"a\" : 42 , \"b\" : \"ignored\" }}, Main ) == Main ( Sub ( 42 )) # However this: load ({ \"sub\" : { \"a\" : 42 }, \"b\" : \"not ignored!\" }, Main ) # Gives: # databind.core.converter.ConversionError: encountered extra keys: {'b'} # Conversion trace: # $: Type(__main__.Main) Allowing extra keys everywhere Providing the ExtraKeys() setting to the settings of a deserialization process will enable it for all schemas, except for those that have a different setting \"closer by\" (you can use ExtraKeys(False) to explicitly not permit extra keys). # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load @dataclass class MyClass : a : int assert load ({ \"a\" : 42 , \"b\" : \"ignore\" }, MyClass , settings = [ ExtraKeys ()]) == MyClass ( 42 ) Recording extra keys You can also record which extra keys have been encountered to report. This is common if you want to allow but warn about unused keys in a payload. # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.core.context import format_context_trace from databind.json import load @dataclass class MyClass : a : int recorded = [] assert load ({ \"a\" : 42 , \"b\" : \"ignore\" }, MyClass , settings = [ ExtraKeys ( recorder = lambda ctx , keys : recorded . append (( ctx , keys )))]) == MyClass ( 42 ) for ctx , keys in recorded : print ( \"warning: unused keys\" , keys , \"at\" ) print ( format_context_trace ( ctx )) # Gives: # # warning: unused keys {'b'} at # $: Type(__main__.MyClass) Dynamic unions with union mappers Todo Unions with literal discriminators When unions are deserialized, they can be accommodated by a \"union mapper\" to identify based on a value in the payload how that payload can be deserialized. However, you can also use Literal type hints on dataca,sses in combination with naive union types. The Literal will fail to deserialize if the value in the payload does not match with the literal value, and naive union types will try all types in the union in order and return the first successfully deserialized type. Note Arguably this is rather inefficient; a better implementation would be to prioritize checking values of literal fields first so we don't need to attempt to deserialize the rest if there's no match. # cat <<EOF | python - import dataclasses from databind.json import load from typing import Literal @dataclasses . dataclass class AwsMachine : region : str name : str instance_id : str provider : Literal [ \"aws\" ] = \"aws\" @dataclasses . dataclass class AzureMachine : resource_group : str name : str provider : Literal [ \"azure\" ] = \"azure\" Machine = AwsMachine | AzureMachine payload = { \"provider\" : \"azure\" , \"resource_group\" : \"foo\" , \"name\" : \"bar\" , } assert load ( payload , Machine ) == AzureMachine ( \"foo\" , \"bar\" )","title":"Examples"},{"location":"examples/#examples","text":"This page shows some common usage examples for using the databind.json library.","title":"Examples"},{"location":"examples/#configuration-deserialization","text":"A common use case is to describe the configuration for an application as dataclasses, then deserialize it from a JSON, YAMl or TOML file. from __future__ import annotations import databind.json import dataclasses import tomlib from pathlib import Path @dataclasses . dataclass class ServerConfig : host : str port : int = 8080 @dataclasses . dataclass class MainConfig : server : ServerConfig @staticmethod def load ( path : Path | str ) -> MainConfig : data = tomlib . loads ( Path ( path ) . read_text ()) return databind . json . load ( data , MainConfig , filename = path ) config = MainConfig . load_toml ( \"config.toml\" ) An example config TOML file that can be parsed with the above configuration: [server] host = \"localhost\" port = 8080 Note that any extra keys that are not expected per the schema will raise a databind.core.converter.ConversionError . Danger Databind uses Python runtime type annotation introspection using the typeapi package. This requires that all type annotations that databind comes in contact with must be valid expressions in the current Python version, even if from __future__ import annotations is used. This means if your code needs to be compatible with Python versions lower than 3.10 or 3.9 that you can not use the new type union syntax ( a | b ) or built-in generic aliases (such as list[int] ) and need to continue to use typing.Union , typing.Optional and typing.List , etc.","title":"Configuration deserialization"},{"location":"examples/#permitting-unknown-keys","text":"If you would like to permit extra keys to to be present in a payload that is being deserialized without raising a databind.core.converter.ConversionError , you can use the databind.core.settings.ExtraKeys setting to annotate a @dataclass , an annotation or specify it globally to allow extra keys anywhere. When using this setting, you can also record any unexpected keys so you can report them after the deserialization.","title":"Permitting unknown keys"},{"location":"examples/#allowing-extra-keys-on-a-dataclass","text":"# cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load @ExtraKeys () @dataclass class MyClass : a : int assert load ({ \"a\" : 42 , \"b\" : \"ignored\" }, MyClass ) == MyClass ( 42 ) Note The ExtraKeys setting does not apply transitively to the members of the dataclass.","title":"Allowing extra keys on a dataclass"},{"location":"examples/#allowing-extra-keys-on-a-dataclass-member","text":"# cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load from typing_extensions import Annotated @dataclass class Sub : a : int @dataclass class Main : sub : Annotated [ Sub , ExtraKeys ()] assert load ({ \"sub\" : { \"a\" : 42 , \"b\" : \"ignored\" }}, Main ) == Main ( Sub ( 42 )) # However this: load ({ \"sub\" : { \"a\" : 42 }, \"b\" : \"not ignored!\" }, Main ) # Gives: # databind.core.converter.ConversionError: encountered extra keys: {'b'} # Conversion trace: # $: Type(__main__.Main)","title":"Allowing extra keys on a dataclass member"},{"location":"examples/#allowing-extra-keys-everywhere","text":"Providing the ExtraKeys() setting to the settings of a deserialization process will enable it for all schemas, except for those that have a different setting \"closer by\" (you can use ExtraKeys(False) to explicitly not permit extra keys). # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.json import load @dataclass class MyClass : a : int assert load ({ \"a\" : 42 , \"b\" : \"ignore\" }, MyClass , settings = [ ExtraKeys ()]) == MyClass ( 42 )","title":"Allowing extra keys everywhere"},{"location":"examples/#recording-extra-keys","text":"You can also record which extra keys have been encountered to report. This is common if you want to allow but warn about unused keys in a payload. # cat <<EOF | python - from dataclasses import dataclass from databind.core.settings import ExtraKeys from databind.core.context import format_context_trace from databind.json import load @dataclass class MyClass : a : int recorded = [] assert load ({ \"a\" : 42 , \"b\" : \"ignore\" }, MyClass , settings = [ ExtraKeys ( recorder = lambda ctx , keys : recorded . append (( ctx , keys )))]) == MyClass ( 42 ) for ctx , keys in recorded : print ( \"warning: unused keys\" , keys , \"at\" ) print ( format_context_trace ( ctx )) # Gives: # # warning: unused keys {'b'} at # $: Type(__main__.MyClass)","title":"Recording extra keys"},{"location":"examples/#dynamic-unions-with-union-mappers","text":"Todo","title":"Dynamic unions with union mappers"},{"location":"examples/#unions-with-literal-discriminators","text":"When unions are deserialized, they can be accommodated by a \"union mapper\" to identify based on a value in the payload how that payload can be deserialized. However, you can also use Literal type hints on dataca,sses in combination with naive union types. The Literal will fail to deserialize if the value in the payload does not match with the literal value, and naive union types will try all types in the union in order and return the first successfully deserialized type. Note Arguably this is rather inefficient; a better implementation would be to prioritize checking values of literal fields first so we don't need to attempt to deserialize the rest if there's no match. # cat <<EOF | python - import dataclasses from databind.json import load from typing import Literal @dataclasses . dataclass class AwsMachine : region : str name : str instance_id : str provider : Literal [ \"aws\" ] = \"aws\" @dataclasses . dataclass class AzureMachine : resource_group : str name : str provider : Literal [ \"azure\" ] = \"azure\" Machine = AwsMachine | AzureMachine payload = { \"provider\" : \"azure\" , \"resource_group\" : \"foo\" , \"name\" : \"bar\" , } assert load ( payload , Machine ) == AzureMachine ( \"foo\" , \"bar\" )","title":"Unions with literal discriminators"},{"location":"api/databind.core.context/","text":"Class Root class Root ( enum . Enum ) [view_source] A singleton to represent that a Context is pointing to the root of the payload. Class Location @dataclasses . dataclass ( frozen = True ) class Location () [view_source] Represents a location in a file. filename The name of the file. line The line number in the file. column The column number in the file. Class Context @dataclasses . dataclass class Context () [view_source] The context is constructed by the ObjectMapper and passed to an applicable Converter to convert value according to the datatype . parent The parent context. direction The direction (i.e. deserialization or serialization). value The value to convert. datatype The expected datatype of the value to inform the converter of what to convert the value from or to. settings A list of Settings that are to be taken into account by the converter which can potentialy impact the conversion process. key The key or index under which value is present in the source material relative to the parent context. This is None only for the root value in the same source. The value must be Context.ROOT if the context has no parent. location The location of the value in the source material. convert_func A function to dispatch the further conversion of a Context . get_setting def get_setting ( setting_type : t . Type [ T_Setting ]) -> T_Setting | None [view_source] Retrieve a setting by type that for the current context. spawn def spawn ( value : t . Any , datatype : t . Union [ typeapi . Hint , t . Any ], key : t . Union [ int , str , None ], location : t . Optional [ Location ] = None ) -> Context [view_source] Spawn a sub context with a new value, datatype, key and optionally a new location. If the location is not overwritten, the parent filename is inherited, but not line number and column. Arguments : value - The value to convert. datatype - The datatype of value . If this is not already a typeapi.Hint , it will be converted to one using typeapi.of() . key - The key or index at which the value can be found relative to the parent. location - The location of the new value. If not specified, the parent filename is inherited but not the line number and column. Returns : A new Context object that has self as its parent . convert def convert () -> t . Any [view_source] Invoke the convert_func with self . format_context_trace def format_context_trace ( ctx : Context ) -> str [view_source] Formats a trace for the given context that is convenient to inspect in case of errors to understand where the context is pointing to in the payload that is being converted.","title":"databind.core.context"},{"location":"api/databind.core.context/#class-root","text":"class Root ( enum . Enum ) [view_source] A singleton to represent that a Context is pointing to the root of the payload.","title":"Class Root"},{"location":"api/databind.core.context/#class-location","text":"@dataclasses . dataclass ( frozen = True ) class Location () [view_source] Represents a location in a file.","title":"Class Location"},{"location":"api/databind.core.context/#filename","text":"The name of the file.","title":"filename"},{"location":"api/databind.core.context/#line","text":"The line number in the file.","title":"line"},{"location":"api/databind.core.context/#column","text":"The column number in the file.","title":"column"},{"location":"api/databind.core.context/#class-context","text":"@dataclasses . dataclass class Context () [view_source] The context is constructed by the ObjectMapper and passed to an applicable Converter to convert value according to the datatype .","title":"Class Context"},{"location":"api/databind.core.context/#parent","text":"The parent context.","title":"parent"},{"location":"api/databind.core.context/#direction","text":"The direction (i.e. deserialization or serialization).","title":"direction"},{"location":"api/databind.core.context/#value","text":"The value to convert.","title":"value"},{"location":"api/databind.core.context/#datatype","text":"The expected datatype of the value to inform the converter of what to convert the value from or to.","title":"datatype"},{"location":"api/databind.core.context/#settings","text":"A list of Settings that are to be taken into account by the converter which can potentialy impact the conversion process.","title":"settings"},{"location":"api/databind.core.context/#key","text":"The key or index under which value is present in the source material relative to the parent context. This is None only for the root value in the same source. The value must be Context.ROOT if the context has no parent.","title":"key"},{"location":"api/databind.core.context/#location","text":"The location of the value in the source material.","title":"location"},{"location":"api/databind.core.context/#convert_func","text":"A function to dispatch the further conversion of a Context .","title":"convert_func"},{"location":"api/databind.core.context/#get_setting","text":"def get_setting ( setting_type : t . Type [ T_Setting ]) -> T_Setting | None [view_source] Retrieve a setting by type that for the current context.","title":"get_setting"},{"location":"api/databind.core.context/#spawn","text":"def spawn ( value : t . Any , datatype : t . Union [ typeapi . Hint , t . Any ], key : t . Union [ int , str , None ], location : t . Optional [ Location ] = None ) -> Context [view_source] Spawn a sub context with a new value, datatype, key and optionally a new location. If the location is not overwritten, the parent filename is inherited, but not line number and column. Arguments : value - The value to convert. datatype - The datatype of value . If this is not already a typeapi.Hint , it will be converted to one using typeapi.of() . key - The key or index at which the value can be found relative to the parent. location - The location of the new value. If not specified, the parent filename is inherited but not the line number and column. Returns : A new Context object that has self as its parent .","title":"spawn"},{"location":"api/databind.core.context/#convert","text":"def convert () -> t . Any [view_source] Invoke the convert_func with self .","title":"convert"},{"location":"api/databind.core.context/#format_context_trace","text":"def format_context_trace ( ctx : Context ) -> str [view_source] Formats a trace for the given context that is convenient to inspect in case of errors to understand where the context is pointing to in the payload that is being converted.","title":"format_context_trace"},{"location":"api/databind.core.converter/","text":"Class Converter class Converter ( abc . ABC ) [view_source] Interface for converting a value from one representation to another. convert def convert ( ctx : Context ) -> t . Any [view_source] Convert the value in ctx to another value. The default implementation will dispatch to serialize() and deserialize() depending on the direction given by the context. Because these methods raise NotImplementedError , an instance of Converter without custom logic will effectively be a no-op. Argument: ctx: The conversion context that contains the direction, value, datatype, settings, location and allows you to recursively continue the conversion process for sub values. Raises : NotImplementedError - If the converter does not support the conversion for the given context. NoMatchingConverter - If the converter is delegating to other converters, to point out that none of its delegates can convert the value. Returns : The new value. Class Module class Module ( Converter ) [view_source] A module is a collection of Converters . Class ConversionError class ConversionError ( Exception ) [view_source] For any errors that occur during conversion. Class NoMatchingConverter class NoMatchingConverter ( ConversionError ) [view_source] If no converter matched to convert the value and datatype in the context.","title":"databind.core.converter"},{"location":"api/databind.core.converter/#class-converter","text":"class Converter ( abc . ABC ) [view_source] Interface for converting a value from one representation to another.","title":"Class Converter"},{"location":"api/databind.core.converter/#convert","text":"def convert ( ctx : Context ) -> t . Any [view_source] Convert the value in ctx to another value. The default implementation will dispatch to serialize() and deserialize() depending on the direction given by the context. Because these methods raise NotImplementedError , an instance of Converter without custom logic will effectively be a no-op. Argument: ctx: The conversion context that contains the direction, value, datatype, settings, location and allows you to recursively continue the conversion process for sub values. Raises : NotImplementedError - If the converter does not support the conversion for the given context. NoMatchingConverter - If the converter is delegating to other converters, to point out that none of its delegates can convert the value. Returns : The new value.","title":"convert"},{"location":"api/databind.core.converter/#class-module","text":"class Module ( Converter ) [view_source] A module is a collection of Converters .","title":"Class Module"},{"location":"api/databind.core.converter/#class-conversionerror","text":"class ConversionError ( Exception ) [view_source] For any errors that occur during conversion.","title":"Class ConversionError"},{"location":"api/databind.core.converter/#class-nomatchingconverter","text":"class NoMatchingConverter ( ConversionError ) [view_source] If no converter matched to convert the value and datatype in the context.","title":"Class NoMatchingConverter"},{"location":"api/databind.core.dataclasses/","text":"Provides a wrapper for dataclasses.dataclass and dataclasses.field that supports non-default arguments following default arguments. The arguments can be specified as positional arguments if the intermediate default arguments are populated as well, or as keyword arguments. The module is supposed to be a drop-in replacement of wherever dataclasses is used. Requires the databind.mypy module to support type checking. Note: make_dataclass is not currently overridden, so it will not support non-default arguments following default arguments. dataclass def dataclass ( cls = None , ** kwargs ) [view_source] A wrapper for the dataclasses.dataclass() decorator that allows non-default arguments to follow default arguments. field def field ( * , annotations = None , metadata = None , ** kwargs ) [view_source] A wrapper for dataclasses.field() that accepts an additional \"annotations\" argument that will propagated into the field's \"databind.core.annotations\" metadata field.","title":"databind.core.dataclasses"},{"location":"api/databind.core.dataclasses/#dataclass","text":"def dataclass ( cls = None , ** kwargs ) [view_source] A wrapper for the dataclasses.dataclass() decorator that allows non-default arguments to follow default arguments.","title":"dataclass"},{"location":"api/databind.core.dataclasses/#field","text":"def field ( * , annotations = None , metadata = None , ** kwargs ) [view_source] A wrapper for dataclasses.field() that accepts an additional \"annotations\" argument that will propagated into the field's \"databind.core.annotations\" metadata field.","title":"field"},{"location":"api/databind.core.mapper/","text":"Class ObjectMapper class ObjectMapper ( t . Generic [ T , U ]) [view_source] The object mapper is responsible for dispatching the conversion process into a Module . The type parameter T represents the deserialized type, while U represents the serialized type. convert def convert ( direction : Direction , value : t . Any , datatype : t . Union [ typeapi . Hint , t . Any ], location : t . Optional [ Location ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> t . Any [view_source] Convert a value according to the given datatype. Arguments : direction - (Added in databind.core 0.3.0) The direction (i.e. either deserialization or serialization). value - The value to convert. datatype - The datatype. If not already a typeapi.Hint instance, it will be converted using typeapi.of() . location - The location of where value is coming from. Useful to specify to make debugging easier. settings - A list of settings, in which case they will be treated as global settings in addition to the mapper's settings , or an entirely different SettingsProvider instance (for which it is recommended that it is taking the ObjectMapper's settings into account, for example by passing them for the Settings.parent ). Raises : ConversionError - For more generic errosr during the conversion process. NoMatchingConverter - If at any point during the conversion a datatype was encountered for which no matching converter was found. serialize def serialize ( value : T , datatype : t . Union [ typeapi . Hint , t . Any ], filename : t . Optional [ str ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> U [view_source] Serialize value according to the its datatype . deserialize def deserialize ( value : U , datatype : t . Union [ typeapi . Hint , t . Any ], filename : t . Optional [ str ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> T [view_source] Deserialize value according to the its datatype .","title":"databind.core.mapper"},{"location":"api/databind.core.mapper/#class-objectmapper","text":"class ObjectMapper ( t . Generic [ T , U ]) [view_source] The object mapper is responsible for dispatching the conversion process into a Module . The type parameter T represents the deserialized type, while U represents the serialized type.","title":"Class ObjectMapper"},{"location":"api/databind.core.mapper/#convert","text":"def convert ( direction : Direction , value : t . Any , datatype : t . Union [ typeapi . Hint , t . Any ], location : t . Optional [ Location ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> t . Any [view_source] Convert a value according to the given datatype. Arguments : direction - (Added in databind.core 0.3.0) The direction (i.e. either deserialization or serialization). value - The value to convert. datatype - The datatype. If not already a typeapi.Hint instance, it will be converted using typeapi.of() . location - The location of where value is coming from. Useful to specify to make debugging easier. settings - A list of settings, in which case they will be treated as global settings in addition to the mapper's settings , or an entirely different SettingsProvider instance (for which it is recommended that it is taking the ObjectMapper's settings into account, for example by passing them for the Settings.parent ). Raises : ConversionError - For more generic errosr during the conversion process. NoMatchingConverter - If at any point during the conversion a datatype was encountered for which no matching converter was found.","title":"convert"},{"location":"api/databind.core.mapper/#serialize","text":"def serialize ( value : T , datatype : t . Union [ typeapi . Hint , t . Any ], filename : t . Optional [ str ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> U [view_source] Serialize value according to the its datatype .","title":"serialize"},{"location":"api/databind.core.mapper/#deserialize","text":"def deserialize ( value : U , datatype : t . Union [ typeapi . Hint , t . Any ], filename : t . Optional [ str ] = None , settings : t . Union [ SettingsProvider , t . List [ Setting ], None ] = None ) -> T [view_source] Deserialize value according to the its datatype .","title":"deserialize"},{"location":"api/databind.core.schema/","text":"Class Field @dataclasses . dataclass class Field () [view_source] Describes a field in a schema. datatype The datatype of the field. required Whether the field is required to be present, if this is False and the field does not have a default or default_factorty , the field value will not be passed to the schema constructor. Even if a default or default_factory is present, if he field is required it must be present in the payload being deserialized. default The default value for the field, if any. default_factory The default value factory for the field, if any. flattened Indicates whether the field is to be treated \"flat\". If the datatype is a structured type that has fields of its own, those fields should be treated as if expanded into the same level as this field. aliases @property def aliases () -> t . Tuple [ str , ... ] [view_source] For convience, the aliases described in the datatype #'s annotations are listed here. Do note however, that during the conversion process, the Alias setting should still be looked up through Context.get_setting() and this field should be ignored. It serves only a introspective purpose. Returns an empty tuple if no alias setting is present in the type hint. Class Schema @dataclasses . dataclass class Schema () [view_source] A Schema describes a set of fields with a name and datatype. fields A dictionary that maps the field descriptions in the schema. The key is the name of the field in code. Given an instance of an object that complies to a given Schema , this is the name by which the value of the field should be read using attribute lookup. constructor A function that constructs an instance of a Python object that this schema represents given a dictionary as keyword arguments of the deserialized field values. Fields that are not present in the source payload and a that do not have a default value will not be present in the passed dictionary. type The underlying native Python type associated with the schema. annotations Annotation metadata that goes with the schema, possibly derived from a typeapi.Annotated hint or the underlying Python type object. convert_to_schema def convert_to_schema ( hint : typeapi . Hint ) -> Schema [view_source] Convert the given type hint to a Schema . The function delegates to convert_dataclass_to_schema() or convert_typed_dict_to_schema() . Arguments : hint - The type hint to convert. If it is a typeapi.Annotated hint, it will be unwrapped. Raises : ValueError - If the type hint is not supported. convert_dataclass_to_schema def convert_dataclass_to_schema ( dataclass_type : t . Union [ type , GenericAlias , typeapi . Type ]) -> Schema [view_source] Converts a Python class that is decorated with dataclasses.dataclass() . The function will respect the Required setting if it is present in a field's datatype if and only if the setting occurs in the root type hint, which must be a typing.Annotated hint. Arguments : dataclass_type - A Python type that is a dataclass, or a generic alias of a dataclass. Returns : A schema that represents the dataclass. If a generic alias was passed, fields of which the type hint contained type parameters will have their type parameters substituted with the respective arguments present in the alias. Example : import dataclasses import typing as t import typeapi from databind.core.schema import convert_dataclass_to_schema , Field , Schema T = t . TypeVar ( 'T' ) @dataclasses . dataclass class A ( t . Generic [ T ]): a : T assert convert_dataclass_to_schema ( A [ int ]) == Schema ({ 'a' : Field ( typeapi . of ( int ))}, A ) convert_typed_dict_to_schema def convert_typed_dict_to_schema ( typed_dict : typeapi . utils . TypedDict ) -> Schema [view_source] Converts the definition of a typing.TypedDict to a Schema . Note This function will take into account default values assigned on the class-level of the typed dict (which is usually only relevant if the class-style declaration method was used, but default values can be assigned to the function-style declared type as well). Fields that have default values are considered not-required even if the declaration specifies them as required. Be aware that right-hand side values on typing.TypedDict classes are not allowed by Mypy. Also note that typing.TypedDict cannot be mixed with typing.Generic , so keys with a generic type in the typed dict are not possible (state: 2022-03-17, Python 3.10.2). Todo Support understanding typing.Required and typing.NotRequired . Example : from databind.core.schema import convert_typed_dict_to_schema , Schema , Field import typing class Movie ( typing . TypedDict ): name : str year : int = 0 assert convert_typed_dict_to_schema ( Movie ) == Schema ({ 'name' : Field ( typeapi . of ( str )), 'year' : Field ( typeapi . of ( int ), False , 0 ), }, Movie ) get_fields_expanded def get_fields_expanded ( schema : Schema , convert_to_schema : t . Callable [[ typeapi . Hint ], Schema ] = convert_to_schema ) -> t . Dict [ str , t . Dict [ str , Field ]] [view_source] Returns a dictionary that contains an entry for each flattened field in the schema, mapping to another dictionary that contains all fields expanded from the flattened field's sub-schema. Given a schema like the following example, this function returns something akin to the below. Schema Schema1: a: int b: Schema2, flattened=True Schema2: c: str d: Schema3, flattened=True Schema3: e: int Result { \"b\" : { \"c\" : Field ( str ), \"e\" : Field ( int ) } } ** Arguments ** : - ` schema ` - The schema to compile the expanded fields for . - ` convert_to_schema ` - A function that accepts a ` typeapi . Hint ` and converts it to a schema . Defaults to the [ convert_to_schema ()]( #pydoc:databind.core.schema.convert_to_schema) function. !!! note The top - level dictionary returned by this function contains _only_ those fields that are flattened and should be \"composed\" of other fields .","title":"databind.core.schema"},{"location":"api/databind.core.schema/#class-field","text":"@dataclasses . dataclass class Field () [view_source] Describes a field in a schema.","title":"Class Field"},{"location":"api/databind.core.schema/#datatype","text":"The datatype of the field.","title":"datatype"},{"location":"api/databind.core.schema/#required","text":"Whether the field is required to be present, if this is False and the field does not have a default or default_factorty , the field value will not be passed to the schema constructor. Even if a default or default_factory is present, if he field is required it must be present in the payload being deserialized.","title":"required"},{"location":"api/databind.core.schema/#default","text":"The default value for the field, if any.","title":"default"},{"location":"api/databind.core.schema/#default_factory","text":"The default value factory for the field, if any.","title":"default_factory"},{"location":"api/databind.core.schema/#flattened","text":"Indicates whether the field is to be treated \"flat\". If the datatype is a structured type that has fields of its own, those fields should be treated as if expanded into the same level as this field.","title":"flattened"},{"location":"api/databind.core.schema/#aliases","text":"@property def aliases () -> t . Tuple [ str , ... ] [view_source] For convience, the aliases described in the datatype #'s annotations are listed here. Do note however, that during the conversion process, the Alias setting should still be looked up through Context.get_setting() and this field should be ignored. It serves only a introspective purpose. Returns an empty tuple if no alias setting is present in the type hint.","title":"aliases"},{"location":"api/databind.core.schema/#class-schema","text":"@dataclasses . dataclass class Schema () [view_source] A Schema describes a set of fields with a name and datatype.","title":"Class Schema"},{"location":"api/databind.core.schema/#fields","text":"A dictionary that maps the field descriptions in the schema. The key is the name of the field in code. Given an instance of an object that complies to a given Schema , this is the name by which the value of the field should be read using attribute lookup.","title":"fields"},{"location":"api/databind.core.schema/#constructor","text":"A function that constructs an instance of a Python object that this schema represents given a dictionary as keyword arguments of the deserialized field values. Fields that are not present in the source payload and a that do not have a default value will not be present in the passed dictionary.","title":"constructor"},{"location":"api/databind.core.schema/#type","text":"The underlying native Python type associated with the schema.","title":"type"},{"location":"api/databind.core.schema/#annotations","text":"Annotation metadata that goes with the schema, possibly derived from a typeapi.Annotated hint or the underlying Python type object.","title":"annotations"},{"location":"api/databind.core.schema/#convert_to_schema","text":"def convert_to_schema ( hint : typeapi . Hint ) -> Schema [view_source] Convert the given type hint to a Schema . The function delegates to convert_dataclass_to_schema() or convert_typed_dict_to_schema() . Arguments : hint - The type hint to convert. If it is a typeapi.Annotated hint, it will be unwrapped. Raises : ValueError - If the type hint is not supported.","title":"convert_to_schema"},{"location":"api/databind.core.schema/#convert_dataclass_to_schema","text":"def convert_dataclass_to_schema ( dataclass_type : t . Union [ type , GenericAlias , typeapi . Type ]) -> Schema [view_source] Converts a Python class that is decorated with dataclasses.dataclass() . The function will respect the Required setting if it is present in a field's datatype if and only if the setting occurs in the root type hint, which must be a typing.Annotated hint. Arguments : dataclass_type - A Python type that is a dataclass, or a generic alias of a dataclass. Returns : A schema that represents the dataclass. If a generic alias was passed, fields of which the type hint contained type parameters will have their type parameters substituted with the respective arguments present in the alias. Example : import dataclasses import typing as t import typeapi from databind.core.schema import convert_dataclass_to_schema , Field , Schema T = t . TypeVar ( 'T' ) @dataclasses . dataclass class A ( t . Generic [ T ]): a : T assert convert_dataclass_to_schema ( A [ int ]) == Schema ({ 'a' : Field ( typeapi . of ( int ))}, A )","title":"convert_dataclass_to_schema"},{"location":"api/databind.core.schema/#convert_typed_dict_to_schema","text":"def convert_typed_dict_to_schema ( typed_dict : typeapi . utils . TypedDict ) -> Schema [view_source] Converts the definition of a typing.TypedDict to a Schema . Note This function will take into account default values assigned on the class-level of the typed dict (which is usually only relevant if the class-style declaration method was used, but default values can be assigned to the function-style declared type as well). Fields that have default values are considered not-required even if the declaration specifies them as required. Be aware that right-hand side values on typing.TypedDict classes are not allowed by Mypy. Also note that typing.TypedDict cannot be mixed with typing.Generic , so keys with a generic type in the typed dict are not possible (state: 2022-03-17, Python 3.10.2). Todo Support understanding typing.Required and typing.NotRequired . Example : from databind.core.schema import convert_typed_dict_to_schema , Schema , Field import typing class Movie ( typing . TypedDict ): name : str year : int = 0 assert convert_typed_dict_to_schema ( Movie ) == Schema ({ 'name' : Field ( typeapi . of ( str )), 'year' : Field ( typeapi . of ( int ), False , 0 ), }, Movie )","title":"convert_typed_dict_to_schema"},{"location":"api/databind.core.schema/#get_fields_expanded","text":"def get_fields_expanded ( schema : Schema , convert_to_schema : t . Callable [[ typeapi . Hint ], Schema ] = convert_to_schema ) -> t . Dict [ str , t . Dict [ str , Field ]] [view_source] Returns a dictionary that contains an entry for each flattened field in the schema, mapping to another dictionary that contains all fields expanded from the flattened field's sub-schema. Given a schema like the following example, this function returns something akin to the below. Schema Schema1: a: int b: Schema2, flattened=True Schema2: c: str d: Schema3, flattened=True Schema3: e: int Result { \"b\" : { \"c\" : Field ( str ), \"e\" : Field ( int ) } } ** Arguments ** : - ` schema ` - The schema to compile the expanded fields for . - ` convert_to_schema ` - A function that accepts a ` typeapi . Hint ` and converts it to a schema . Defaults to the [ convert_to_schema ()]( #pydoc:databind.core.schema.convert_to_schema) function. !!! note The top - level dictionary returned by this function contains _only_ those fields that are flattened and should be \"composed\" of other fields .","title":"get_fields_expanded"},{"location":"api/databind.core.settings/","text":"Class SettingsProvider class SettingsProvider ( abc . ABC ) [view_source] Interface for providing settings. Class Settings class Settings ( SettingsProvider ) [view_source] This class is used as a container for other objects that serve as a provider of settings that may taken into account during data conversion. Objects that provide settings are instances of Setting subclasses, such as FieldAlias or DateFormat . Depending on the type of setting, they may be taken into account if present on a field of a dataclass, or globally from an instance of the Settings class that is passed to the ObjectMapper , or both. Which settings are recognized and considered depends also on the implementation of the converter(s) being used. The Settings class provides capabilities to supply global settings, as well as supplying settings conditionally based on the type that is being looked at by the ObjectMapper at the given point in time. Example : from databind.core.settings import DateFormat , Priority , Settings , Strict settings = Settings () settings . add_global ( DateFormat ( '.ISO_8601' , priority = Priority . HIGH )) settings . add_local ( int , Strict ( false )) add_global def add_global ( setting : Setting ) -> None [view_source] Add a global setting. add_local def add_local ( type_ : type , setting : Setting ) -> None [view_source] Add a setting locally for a particular Python type. If that Python type is encountered, the settings are combined with any other settings that are found for the type. add_conditional def add_conditional ( predicate : t . Callable [[ Context ], bool ], setting : Setting ) -> None [view_source] Adds a setting conditional on the given predicate . add_provider def add_provider ( provider : t . Callable [[ Context ], t . List [ Setting ]]) -> None [view_source] Add a provider callback that is invoked for every conversion context to provide additional settings that the subsequent converter should have access to. get_setting def get_setting ( context : Context , setting_type : t . Type [ T_Setting ]) -> t . Optional [ T_Setting ] [view_source] Resolves the highest priority instance of the given setting type relevant to the current context. The places that the setting is looked for are, in order: If the context's datatype is typeapi.Annotated , look for it in the typeapi.Annotated.metadata . Otherwise, use the wrapped type in the following steps. If the datatype is a typeapi.Type , look for it as a class setting, then subsequently in the settings added with add_local() . Check the setting providers added with add_provider() or add_conditional() . Look for it in the global settings. Delegate to the parent settings provider (if any). If multiple settings are find using any of these steps, the setting with the highest priority among the settings is returned. If multiple settings have the same priority, the setting found first via the above order is returned. Class Priority class Priority ( enum . IntEnum ) [view_source] The priority for settings determines their order in the presence of multiple conflicting settings. Settings should default to using the NORMAL priority. The other priorities are used to either prevent overriding a field setting globally or to enforce overriding of local field settings globally using Settings . Class Setting class Setting () [view_source] Base class for types of which instances represent a setting to be taken into account during data conversion. Every setting has a priority that is used to construct and order or to determine the single setting to use in the presence of multiple instances of the same setting type being present. Settings are usually attached to dataclass fields using typing.Annotated , or added to a Settings object for applying the setting globally, but some subclasses may support being used as decorators to attach the setting to a type object. Such settings would registers themselves under the __databind_settings__ attribute (created if it does not exist) such that it can be picked up when introspected by a converter. Such Setting subclasses should inherit from DecoratorSetting instead. Class ClassDecoratorSetting class ClassDecoratorSetting ( Setting ) [view_source] __call__ def __call__ ( type_ : type ) -> type [view_source] Decorate the class type_ with this setting, adding the setting to its __databind_settings__ list (which is created if it does not exist) and sets bound_to . The same setting instance cannot decorate multiple types. get_highest_setting def get_highest_setting ( settings : t . Iterable [ T_Setting ]) -> T_Setting | None [view_source] Return the first, highest setting of settings . get_class_settings def get_class_settings ( type_ : type , setting_type : t . Type [ T_ClassDecoratorSetting ] ) -> t . Iterable [ T_ClassDecoratorSetting ] [view_source] Returns all matching settings on type_ . get_class_setting def get_class_setting ( type_ : type , setting_type : t . Type [ T_ClassDecoratorSetting ] ) -> T_ClassDecoratorSetting | None [view_source] Returns the first instance of the given setting_type on type_ . get_annotation_setting def get_annotation_setting ( type_ : typeapi . Hint , setting_type : t . Type [ T_Setting ]) -> T_Setting | None [view_source] Returns the first setting of the given setting_type from the given type hint from inspecting the metadata of the typeapi.Annotated . Returns None if no such setting exists or if type_ is not an typeapi.Annotated instance. Class BooleanSetting @dataclasses . dataclass class BooleanSetting ( Setting ) [view_source] Base class for boolean settings. Class Alias class Alias ( Setting ) [view_source] The Alias setting is used to attach one or more alternative names to a dataclass field that should be used instead of the field's name in the code. Example : import typing from dataclasses import dataclass from databind.core.settings import Alias @dataclass class MyClass : my_field : typing . Annotated [ int , Alias ( 'foobar' , 'spam' )] When deserializing a payload, converters should now use foobar if it exists, or fall back to spam when looking up the value for the field in the payload as opposed to my_field . When serializing, converters should use foobar as the name in the generated payload (always the first alias). aliases A tuple of the aliases provided to the constructor. Class Required class Required ( BooleanSetting ) [view_source] Indicates whether a field is required during deserialization, even if it's type specifies that it is an optional field. Example : import typing from dataclasses import dataclass from databind.core.settings import Required @dataclass class MyClass : my_field : typing . Annotated [ typing . Optional [ int ], Required ()] Class Flattened class Flattened ( BooleanSetting ) [view_source] Indicates whether a field should be \"flattened\" by virtually expanding it's sub fields into the parent datastructure's serialized form. Example : import typing from dataclasses import dataclass from databind.core.settings import Flattened @dataclass class Inner : a : int b : str @dataclass class Outter : inner : typing . Annotated [ Inner , Flattened ()] c : str The Outter class in the example above may be deserialized, for example, from a JSON payload of the form - `{\"a\" - 0, \"b\": \"\", \"c\": \"\"} as opposed to , \"c\": \"\"} due to the Outter.inner field's sub fields being expanded into Outter`. Class Strict class Strict ( BooleanSetting ) [view_source] Enable strict conversion of the field during conversion (this should be the default for converters unless some maybe available option to affect the strictness in a converter is changed). This setting should particularly affect only loss-less type conversions (such as int to string and the reverse being allowed when strict handling is disabled). Class SerializeDefaults class SerializeDefaults ( BooleanSetting ) [view_source] Control whether default values are to be encoded in the serialized form of a structure. The default behaviour is up to the serializer implementation, though we consider it good practices to include values that match the default value of a field by default. However, using the setting defaults to enabled having a value of True due to how the name of the setting appears assertive of the fact that the instance indicates the setting is enabled. Class Precision @dataclasses . dataclass class Precision ( Setting ) [view_source] A setting to describe the precision for decimal.Decimal fields. Class Union @dataclasses . dataclass class Union ( ClassDecoratorSetting ) [view_source] A setting that decorates a class or can be attached to the typing.Annotated metadata of a typing.Union type hint to specify that the type should be regarded as a union of more than one types. Which concrete type is to be used at the point of deserialization is usually clarified through a discriminator key. Unions may be of various styles that dictate how the discriminator key and the remaining fields are to be stored or read from. For serialiazation, the type of the Python value should inform the converter about which member of the union is being used. If the a union definition has multiple type IDs mapping to the same Python type, the behaviour is entirely up to the converter (an adequate resolution may be to pick the first matching type ID and ignore the remaining matches). Note The the examples for the different styles below, \"type\" is a stand-in for the value of the discriminator_key and ... serves as a stand-in for the remaining fields of the type that is represented by the discriminator. NESTED The nested style in JSON equivalent is best described as {\"type\": \"<typeid>\", \"<typeid>\": { ... }} . FLAT The flat style in JSON equivalent is best described as {\"type\": \"<typeid>\", ... } . KEYED The keyed style in JSON equivalent is best described as {\"<typeid>\": { ... }} . BEST_MATCH The \"best match\" style attempts to deserialize the payload in an implementation-defined order and return the first or best succeeding result. No discriminator key is used. members The subtypes of the union as an implementation of the UnionMembers interface. When constructing the Union setting, a dictionary may be passed in place of a UnionMembers implementation, or a list of UnionMembers to chain them together. Te constructor will also accept a string that is either \"<import>\" , which will be converted to an ImportUnionMembers handler, or a string formatted as \"!<entrypoint>\" , which will be converted to an EntrypointUnionMembers handler. style The style of the union. This should be one of NESTED , FLAT , KEYED or BEST_MATCH . The default is NESTED . discriminator_key The discriminator key to use, if valid for the style . Defaults to \"type\" . nesting_key The key to use when looking up the fields for the member type. Only used with the NESTED style. If not set, the union member's type ID is used as the key. register @staticmethod def register ( extends : type , name : t . Optional [ str ] = None ) -> t . Callable [[ t . Type [ T ]], t . Type [ T ]] [view_source] A convenience method to use as a decorator for classes that should be registered as members of a Union setting that is attached to the type extends . The Union setting on extends must have a StaticUnionMembers members object. The decorated class must also be a subclass of extends . Example : import abc import dataclasses from databind.core.settings import Union @Union () class MyInterface ( abc . ABC ): # ... pass @dataclasses . dataclass @Union . register ( MyInterface , 'some' ) class SomeImplementation ( MyInterface ): # ... pass Class DateFormat @dataclasses . dataclass class DateFormat ( Setting ) [view_source] The DateFormat setting is used to describe the date format to use for datetime.datetime , datetime.date and datetime.time values when formatting them as a string, i.e. usually when the date/time is serialized, and when parsing them. The nr.util.date module provides types to describe the format of a date, time and datetime (see date_format , time_format and datetime_format ), as well as an entire suite of formats for all types of date/time values. Arguments : formats - One or more datetime formats to use when parsing. The first of the formats is used for formatting. Each element must be one of the following: A formatter (like date_format , time_format or datetime_format ), a format_set , a string that is a date/time format, or a string starting with a period ( . ) that names a builtin format set (like .ISO_8601 ) Attempting to use parse() or format() for a date/time value type for which the DateFormat does not provide an applicable format results in a ValueError . parse def parse ( type_ : t . Type [ T_Dtype ], value : str ) -> T_Dtype [view_source] Parse a date/time value from a string. Arguments : type_ - The type to parse the value into, i.e. datetime.date , datetime.time or datetime.datetime . value - The string to parse. Raises : ValueError - If no date format is sufficient to parse value into the given type_ . Returns : The parsed date/time value. format def format ( dt : T_Dtype ) -> str [view_source] Format a date/time value to a string. Arguments : value - The date/time value to format (i.e. an instance of datetime.date , datetime.time or datetime.datetime ). Raises : ValueError - If no date format to format the type of value is available. Returns : The formatted date/time value. Class ExtraKeys class ExtraKeys ( ClassDecoratorSetting ) [view_source] If discovered while deserializing a databind.core.schema.Schema , it's callback is used to inform when extras keys are encountered. If the setting is not available, or if the arg is set to False (the default), it will cause an error. The setting may also be supplied at an individual schema level. Can be used as a decorator for a class to indicate that extra keys on the schema informed by the class are allowed, as a global setting or as an annotation on a schema field. Note Only the first, highest priority annotation is used; thus if you pass a callback for arg it may not be called if the ExtraKeys setting you pass it to is overruled by another. Class Remainder class Remainder ( BooleanSetting ) [view_source] This setting can be used to indicate on a field of a schema that is of a mapping type that it consumes any extra keys that are not otherwise understood by the schema. Note that there can only be a maximum of 1 remainder field in the same schema.","title":"databind.core.settings"},{"location":"api/databind.core.settings/#class-settingsprovider","text":"class SettingsProvider ( abc . ABC ) [view_source] Interface for providing settings.","title":"Class SettingsProvider"},{"location":"api/databind.core.settings/#class-settings","text":"class Settings ( SettingsProvider ) [view_source] This class is used as a container for other objects that serve as a provider of settings that may taken into account during data conversion. Objects that provide settings are instances of Setting subclasses, such as FieldAlias or DateFormat . Depending on the type of setting, they may be taken into account if present on a field of a dataclass, or globally from an instance of the Settings class that is passed to the ObjectMapper , or both. Which settings are recognized and considered depends also on the implementation of the converter(s) being used. The Settings class provides capabilities to supply global settings, as well as supplying settings conditionally based on the type that is being looked at by the ObjectMapper at the given point in time. Example : from databind.core.settings import DateFormat , Priority , Settings , Strict settings = Settings () settings . add_global ( DateFormat ( '.ISO_8601' , priority = Priority . HIGH )) settings . add_local ( int , Strict ( false ))","title":"Class Settings"},{"location":"api/databind.core.settings/#add_global","text":"def add_global ( setting : Setting ) -> None [view_source] Add a global setting.","title":"add_global"},{"location":"api/databind.core.settings/#add_local","text":"def add_local ( type_ : type , setting : Setting ) -> None [view_source] Add a setting locally for a particular Python type. If that Python type is encountered, the settings are combined with any other settings that are found for the type.","title":"add_local"},{"location":"api/databind.core.settings/#add_conditional","text":"def add_conditional ( predicate : t . Callable [[ Context ], bool ], setting : Setting ) -> None [view_source] Adds a setting conditional on the given predicate .","title":"add_conditional"},{"location":"api/databind.core.settings/#add_provider","text":"def add_provider ( provider : t . Callable [[ Context ], t . List [ Setting ]]) -> None [view_source] Add a provider callback that is invoked for every conversion context to provide additional settings that the subsequent converter should have access to.","title":"add_provider"},{"location":"api/databind.core.settings/#get_setting","text":"def get_setting ( context : Context , setting_type : t . Type [ T_Setting ]) -> t . Optional [ T_Setting ] [view_source] Resolves the highest priority instance of the given setting type relevant to the current context. The places that the setting is looked for are, in order: If the context's datatype is typeapi.Annotated , look for it in the typeapi.Annotated.metadata . Otherwise, use the wrapped type in the following steps. If the datatype is a typeapi.Type , look for it as a class setting, then subsequently in the settings added with add_local() . Check the setting providers added with add_provider() or add_conditional() . Look for it in the global settings. Delegate to the parent settings provider (if any). If multiple settings are find using any of these steps, the setting with the highest priority among the settings is returned. If multiple settings have the same priority, the setting found first via the above order is returned.","title":"get_setting"},{"location":"api/databind.core.settings/#class-priority","text":"class Priority ( enum . IntEnum ) [view_source] The priority for settings determines their order in the presence of multiple conflicting settings. Settings should default to using the NORMAL priority. The other priorities are used to either prevent overriding a field setting globally or to enforce overriding of local field settings globally using Settings .","title":"Class Priority"},{"location":"api/databind.core.settings/#class-setting","text":"class Setting () [view_source] Base class for types of which instances represent a setting to be taken into account during data conversion. Every setting has a priority that is used to construct and order or to determine the single setting to use in the presence of multiple instances of the same setting type being present. Settings are usually attached to dataclass fields using typing.Annotated , or added to a Settings object for applying the setting globally, but some subclasses may support being used as decorators to attach the setting to a type object. Such settings would registers themselves under the __databind_settings__ attribute (created if it does not exist) such that it can be picked up when introspected by a converter. Such Setting subclasses should inherit from DecoratorSetting instead.","title":"Class Setting"},{"location":"api/databind.core.settings/#class-classdecoratorsetting","text":"class ClassDecoratorSetting ( Setting ) [view_source]","title":"Class ClassDecoratorSetting"},{"location":"api/databind.core.settings/#__call__","text":"def __call__ ( type_ : type ) -> type [view_source] Decorate the class type_ with this setting, adding the setting to its __databind_settings__ list (which is created if it does not exist) and sets bound_to . The same setting instance cannot decorate multiple types.","title":"__call__"},{"location":"api/databind.core.settings/#get_highest_setting","text":"def get_highest_setting ( settings : t . Iterable [ T_Setting ]) -> T_Setting | None [view_source] Return the first, highest setting of settings .","title":"get_highest_setting"},{"location":"api/databind.core.settings/#get_class_settings","text":"def get_class_settings ( type_ : type , setting_type : t . Type [ T_ClassDecoratorSetting ] ) -> t . Iterable [ T_ClassDecoratorSetting ] [view_source] Returns all matching settings on type_ .","title":"get_class_settings"},{"location":"api/databind.core.settings/#get_class_setting","text":"def get_class_setting ( type_ : type , setting_type : t . Type [ T_ClassDecoratorSetting ] ) -> T_ClassDecoratorSetting | None [view_source] Returns the first instance of the given setting_type on type_ .","title":"get_class_setting"},{"location":"api/databind.core.settings/#get_annotation_setting","text":"def get_annotation_setting ( type_ : typeapi . Hint , setting_type : t . Type [ T_Setting ]) -> T_Setting | None [view_source] Returns the first setting of the given setting_type from the given type hint from inspecting the metadata of the typeapi.Annotated . Returns None if no such setting exists or if type_ is not an typeapi.Annotated instance.","title":"get_annotation_setting"},{"location":"api/databind.core.settings/#class-booleansetting","text":"@dataclasses . dataclass class BooleanSetting ( Setting ) [view_source] Base class for boolean settings.","title":"Class BooleanSetting"},{"location":"api/databind.core.settings/#class-alias","text":"class Alias ( Setting ) [view_source] The Alias setting is used to attach one or more alternative names to a dataclass field that should be used instead of the field's name in the code. Example : import typing from dataclasses import dataclass from databind.core.settings import Alias @dataclass class MyClass : my_field : typing . Annotated [ int , Alias ( 'foobar' , 'spam' )] When deserializing a payload, converters should now use foobar if it exists, or fall back to spam when looking up the value for the field in the payload as opposed to my_field . When serializing, converters should use foobar as the name in the generated payload (always the first alias).","title":"Class Alias"},{"location":"api/databind.core.settings/#aliases","text":"A tuple of the aliases provided to the constructor.","title":"aliases"},{"location":"api/databind.core.settings/#class-required","text":"class Required ( BooleanSetting ) [view_source] Indicates whether a field is required during deserialization, even if it's type specifies that it is an optional field. Example : import typing from dataclasses import dataclass from databind.core.settings import Required @dataclass class MyClass : my_field : typing . Annotated [ typing . Optional [ int ], Required ()]","title":"Class Required"},{"location":"api/databind.core.settings/#class-flattened","text":"class Flattened ( BooleanSetting ) [view_source] Indicates whether a field should be \"flattened\" by virtually expanding it's sub fields into the parent datastructure's serialized form. Example : import typing from dataclasses import dataclass from databind.core.settings import Flattened @dataclass class Inner : a : int b : str @dataclass class Outter : inner : typing . Annotated [ Inner , Flattened ()] c : str The Outter class in the example above may be deserialized, for example, from a JSON payload of the form - `{\"a\" - 0, \"b\": \"\", \"c\": \"\"} as opposed to , \"c\": \"\"} due to the Outter.inner field's sub fields being expanded into Outter`.","title":"Class Flattened"},{"location":"api/databind.core.settings/#class-strict","text":"class Strict ( BooleanSetting ) [view_source] Enable strict conversion of the field during conversion (this should be the default for converters unless some maybe available option to affect the strictness in a converter is changed). This setting should particularly affect only loss-less type conversions (such as int to string and the reverse being allowed when strict handling is disabled).","title":"Class Strict"},{"location":"api/databind.core.settings/#class-serializedefaults","text":"class SerializeDefaults ( BooleanSetting ) [view_source] Control whether default values are to be encoded in the serialized form of a structure. The default behaviour is up to the serializer implementation, though we consider it good practices to include values that match the default value of a field by default. However, using the setting defaults to enabled having a value of True due to how the name of the setting appears assertive of the fact that the instance indicates the setting is enabled.","title":"Class SerializeDefaults"},{"location":"api/databind.core.settings/#class-precision","text":"@dataclasses . dataclass class Precision ( Setting ) [view_source] A setting to describe the precision for decimal.Decimal fields.","title":"Class Precision"},{"location":"api/databind.core.settings/#class-union","text":"@dataclasses . dataclass class Union ( ClassDecoratorSetting ) [view_source] A setting that decorates a class or can be attached to the typing.Annotated metadata of a typing.Union type hint to specify that the type should be regarded as a union of more than one types. Which concrete type is to be used at the point of deserialization is usually clarified through a discriminator key. Unions may be of various styles that dictate how the discriminator key and the remaining fields are to be stored or read from. For serialiazation, the type of the Python value should inform the converter about which member of the union is being used. If the a union definition has multiple type IDs mapping to the same Python type, the behaviour is entirely up to the converter (an adequate resolution may be to pick the first matching type ID and ignore the remaining matches). Note The the examples for the different styles below, \"type\" is a stand-in for the value of the discriminator_key and ... serves as a stand-in for the remaining fields of the type that is represented by the discriminator.","title":"Class Union"},{"location":"api/databind.core.settings/#nested","text":"The nested style in JSON equivalent is best described as {\"type\": \"<typeid>\", \"<typeid>\": { ... }} .","title":"NESTED"},{"location":"api/databind.core.settings/#flat","text":"The flat style in JSON equivalent is best described as {\"type\": \"<typeid>\", ... } .","title":"FLAT"},{"location":"api/databind.core.settings/#keyed","text":"The keyed style in JSON equivalent is best described as {\"<typeid>\": { ... }} .","title":"KEYED"},{"location":"api/databind.core.settings/#best_match","text":"The \"best match\" style attempts to deserialize the payload in an implementation-defined order and return the first or best succeeding result. No discriminator key is used.","title":"BEST_MATCH"},{"location":"api/databind.core.settings/#members","text":"The subtypes of the union as an implementation of the UnionMembers interface. When constructing the Union setting, a dictionary may be passed in place of a UnionMembers implementation, or a list of UnionMembers to chain them together. Te constructor will also accept a string that is either \"<import>\" , which will be converted to an ImportUnionMembers handler, or a string formatted as \"!<entrypoint>\" , which will be converted to an EntrypointUnionMembers handler.","title":"members"},{"location":"api/databind.core.settings/#style","text":"The style of the union. This should be one of NESTED , FLAT , KEYED or BEST_MATCH . The default is NESTED .","title":"style"},{"location":"api/databind.core.settings/#discriminator_key","text":"The discriminator key to use, if valid for the style . Defaults to \"type\" .","title":"discriminator_key"},{"location":"api/databind.core.settings/#nesting_key","text":"The key to use when looking up the fields for the member type. Only used with the NESTED style. If not set, the union member's type ID is used as the key.","title":"nesting_key"},{"location":"api/databind.core.settings/#register","text":"@staticmethod def register ( extends : type , name : t . Optional [ str ] = None ) -> t . Callable [[ t . Type [ T ]], t . Type [ T ]] [view_source] A convenience method to use as a decorator for classes that should be registered as members of a Union setting that is attached to the type extends . The Union setting on extends must have a StaticUnionMembers members object. The decorated class must also be a subclass of extends . Example : import abc import dataclasses from databind.core.settings import Union @Union () class MyInterface ( abc . ABC ): # ... pass @dataclasses . dataclass @Union . register ( MyInterface , 'some' ) class SomeImplementation ( MyInterface ): # ... pass","title":"register"},{"location":"api/databind.core.settings/#class-dateformat","text":"@dataclasses . dataclass class DateFormat ( Setting ) [view_source] The DateFormat setting is used to describe the date format to use for datetime.datetime , datetime.date and datetime.time values when formatting them as a string, i.e. usually when the date/time is serialized, and when parsing them. The nr.util.date module provides types to describe the format of a date, time and datetime (see date_format , time_format and datetime_format ), as well as an entire suite of formats for all types of date/time values. Arguments : formats - One or more datetime formats to use when parsing. The first of the formats is used for formatting. Each element must be one of the following: A formatter (like date_format , time_format or datetime_format ), a format_set , a string that is a date/time format, or a string starting with a period ( . ) that names a builtin format set (like .ISO_8601 ) Attempting to use parse() or format() for a date/time value type for which the DateFormat does not provide an applicable format results in a ValueError .","title":"Class DateFormat"},{"location":"api/databind.core.settings/#parse","text":"def parse ( type_ : t . Type [ T_Dtype ], value : str ) -> T_Dtype [view_source] Parse a date/time value from a string. Arguments : type_ - The type to parse the value into, i.e. datetime.date , datetime.time or datetime.datetime . value - The string to parse. Raises : ValueError - If no date format is sufficient to parse value into the given type_ . Returns : The parsed date/time value.","title":"parse"},{"location":"api/databind.core.settings/#format","text":"def format ( dt : T_Dtype ) -> str [view_source] Format a date/time value to a string. Arguments : value - The date/time value to format (i.e. an instance of datetime.date , datetime.time or datetime.datetime ). Raises : ValueError - If no date format to format the type of value is available. Returns : The formatted date/time value.","title":"format"},{"location":"api/databind.core.settings/#class-extrakeys","text":"class ExtraKeys ( ClassDecoratorSetting ) [view_source] If discovered while deserializing a databind.core.schema.Schema , it's callback is used to inform when extras keys are encountered. If the setting is not available, or if the arg is set to False (the default), it will cause an error. The setting may also be supplied at an individual schema level. Can be used as a decorator for a class to indicate that extra keys on the schema informed by the class are allowed, as a global setting or as an annotation on a schema field. Note Only the first, highest priority annotation is used; thus if you pass a callback for arg it may not be called if the ExtraKeys setting you pass it to is overruled by another.","title":"Class ExtraKeys"},{"location":"api/databind.core.settings/#class-remainder","text":"class Remainder ( BooleanSetting ) [view_source] This setting can be used to indicate on a field of a schema that is of a mapping type that it consumes any extra keys that are not otherwise understood by the schema. Note that there can only be a maximum of 1 remainder field in the same schema.","title":"Class Remainder"},{"location":"api/databind.core.union/","text":"Provides the interface and implementations for representing the members of a union type. Class UnionMembers class UnionMembers ( abc . ABC ) [view_source] Interface for representing the members of a union type. It defines methods to look up member type details based on name and Python type hints. get_type_id @abc . abstractmethod def get_type_id ( type_ : t . Any ) -> str [view_source] Given a Python type, return the ID of the type among the union members. Arguments : type_ - The Python type to retrieve the ID for. Raises : ValueError - If the type_ is not a member of the union. get_type_by_id @abc . abstractmethod def get_type_by_id ( type_id : str ) -> t . Any [view_source] Given type ID, return the Python type associated with that ID among the union members. Arguments : type_id - The ID of the type to retrieve. Raises : ValueError - If the type_id is not an ID among the union members. get_type_ids @abc . abstractmethod def get_type_ids () -> t . List [ str ] [view_source] Returns : A list of the type names known to the union subtypes. Raises : NotImplementedError - If the method not supported by this implementation. Class StaticUnionMembers @dataclasses . dataclass class StaticUnionMembers ( UnionMembers ) [view_source] An implementation of UnionMembers that reads statically from a dictionary. The dictionary can be altered subsequently, which is commonly done to explicitly register a member. The members dictionary values may contain Python types or type hints understood by databind converters, as well as functions that return these types of values to allow for deferred evaluation. Example : from databind.core.union import StaticUnionMembers members = StaticUnionMembers () @members . register ( 'my-type' ) class MyType : pass The register() method is also exposed for your convenience on the Union settings type (see Union.register() ). members The member types dictionary. Class EntrypointUnionMembers @dataclasses . dataclass class EntrypointUnionMembers ( UnionMembers ) [view_source] An implementation of UnionMembers to treat the member type ID as a name for an entry in a entrypoint group. Class ImportUnionMembers class ImportUnionMembers ( UnionMembers ) [view_source] This UnionMembers subclass treats type IDs as fully qualified identifiers by which to import Python classes. This implementation does not support UnionMembers.get_type_ids() . Class ChainUnionMembers @dataclasses . dataclass class ChainUnionMembers ( UnionMembers ) [view_source] Chain multiple implementations of UnionMembers .","title":"databind.core.union"},{"location":"api/databind.core.union/#class-unionmembers","text":"class UnionMembers ( abc . ABC ) [view_source] Interface for representing the members of a union type. It defines methods to look up member type details based on name and Python type hints.","title":"Class UnionMembers"},{"location":"api/databind.core.union/#get_type_id","text":"@abc . abstractmethod def get_type_id ( type_ : t . Any ) -> str [view_source] Given a Python type, return the ID of the type among the union members. Arguments : type_ - The Python type to retrieve the ID for. Raises : ValueError - If the type_ is not a member of the union.","title":"get_type_id"},{"location":"api/databind.core.union/#get_type_by_id","text":"@abc . abstractmethod def get_type_by_id ( type_id : str ) -> t . Any [view_source] Given type ID, return the Python type associated with that ID among the union members. Arguments : type_id - The ID of the type to retrieve. Raises : ValueError - If the type_id is not an ID among the union members.","title":"get_type_by_id"},{"location":"api/databind.core.union/#get_type_ids","text":"@abc . abstractmethod def get_type_ids () -> t . List [ str ] [view_source] Returns : A list of the type names known to the union subtypes. Raises : NotImplementedError - If the method not supported by this implementation.","title":"get_type_ids"},{"location":"api/databind.core.union/#class-staticunionmembers","text":"@dataclasses . dataclass class StaticUnionMembers ( UnionMembers ) [view_source] An implementation of UnionMembers that reads statically from a dictionary. The dictionary can be altered subsequently, which is commonly done to explicitly register a member. The members dictionary values may contain Python types or type hints understood by databind converters, as well as functions that return these types of values to allow for deferred evaluation. Example : from databind.core.union import StaticUnionMembers members = StaticUnionMembers () @members . register ( 'my-type' ) class MyType : pass The register() method is also exposed for your convenience on the Union settings type (see Union.register() ).","title":"Class StaticUnionMembers"},{"location":"api/databind.core.union/#members","text":"The member types dictionary.","title":"members"},{"location":"api/databind.core.union/#class-entrypointunionmembers","text":"@dataclasses . dataclass class EntrypointUnionMembers ( UnionMembers ) [view_source] An implementation of UnionMembers to treat the member type ID as a name for an entry in a entrypoint group.","title":"Class EntrypointUnionMembers"},{"location":"api/databind.core.union/#class-importunionmembers","text":"class ImportUnionMembers ( UnionMembers ) [view_source] This UnionMembers subclass treats type IDs as fully qualified identifiers by which to import Python classes. This implementation does not support UnionMembers.get_type_ids() .","title":"Class ImportUnionMembers"},{"location":"api/databind.core.union/#class-chainunionmembers","text":"@dataclasses . dataclass class ChainUnionMembers ( UnionMembers ) [view_source] Chain multiple implementations of UnionMembers .","title":"Class ChainUnionMembers"},{"location":"api/databind.json.converters/","text":"Class AnyConverter class AnyConverter ( Converter ) [view_source] A converter for typing.Any and object typed values, which will return them unchanged in any case. Class DatetimeConverter class DatetimeConverter ( Converter ) [view_source] A converter for datetime.datetime , datetime.date and datetime.time that represents the serialized form as strings formatted using the nr.util.date module. The converter respects the DateFormat setting. Class DecimalConverter class DecimalConverter ( Converter ) [view_source] A converter for decimal.Decimal values to and from JSON as strings. Class EnumConverter class EnumConverter ( Converter ) [view_source] JSON converter for enum values. Converts enum.IntEnum values to integers and enum.Enum values to strings. Note that combined integer flags are not supported and cannot be serializ Aliases on the type annotation of an enum field are considered as aliases for the field name to be used in the value's serialized form as opposed to its value name defined in code. Example : import enum , typing from databind.core.settings import Alias class Pet ( enum . Enum ): CAT = enum . auto () DOG = enum . auto () LION : typing . Annotated [ int , Alias ( 'KITTY' )] = enum . auto () Class PlainDatatypeConverter class PlainDatatypeConverter ( Converter ) [view_source] A converter for the plain datatypes bool , bytes , int , str and float . Arguments : direction Direction - The direction in which to convert (serialize or deserialize). strict_by_default bool - Whether to use strict type conversion on values by default if no other information on strictness is given. This defaults to True . With strict conversion enabled, loss-less type conversions are disabled (such as casting a string to an integer). Note that serialization is always strict, only the deserialization is controlled with this option or the Strict setting. Class SchemaConverter class SchemaConverter ( Converter ) [view_source] Converter for type hints that can be adapter to a databind.core.schema.Schema object. This converter respects the following settings: Alias SerializeDefaults Class StringifyConverter class StringifyConverter ( Converter ) [view_source] A useful helper converter that matches on a given type or its subclasses and converts them to a string for serialization and deserializes them from a string using the type's constructor. Class UnionConverter class UnionConverter ( Converter ) [view_source] Converter for union types. The following kinds of union types are supported: A typing.Union (represented as typeapi.Union ) instance, in which case the members are deserialized in the the Union.NESTED mode, using the class name as the discriminator keys. AOrB = A | B # ex.: {\"type\": \"A\", \"A\": {...}} A typing.Annotated annotated with the Union setting (represented as typeapi.Annotated ) from databind.core.settings import Union AOrB = typing . Annotated [ A | B , Union ({ 'a' : A , 'b' : B }, Union . KEYED )] # ex.: {\"a\": {...}} A class that is decorated with the Union setting import dataclasses from databind.core.settings import Union @Union ( style = Union . FLAT ) class Base ( abc . ABC ): pass @Union . register ( Base , 'a' ) @dataclasses . dataclass class A ( Base ): pass # ... # ex.: {\"type\": \"a\", ...} Note Note that the union members should be concrete types, not generic aliases, because the converter cannot check if an object is an instance of an alias. This is an implementation detail of the databind.core.union.UnionMembers implementations. More Examples: import abc import typing from databind.core.settings import Union AOrB = typing . Annotated [ typing . Union [ A , B ], Union ({ 'A' : A , 'B' : B }, Union . NESTED , 'uses' , 'with' ) ] @Union ( '!my.package.plugins' ) class Plugin ( abc . ABC ): @abc . abstractmethod def activate ( self ) -> None : ... Class LiteralConverter class LiteralConverter ( Converter ) [view_source] A converter for typing.Literal type hints. A literal value in the definition must simply match the literal value in the context being serialized/deserialized, otherwise a ConversionError is raised. Currently, literal values must be of a plain data type that natively maps to a JSON type, like a boolean, integer, float, string or None .","title":"databind.json.converters"},{"location":"api/databind.json.converters/#class-anyconverter","text":"class AnyConverter ( Converter ) [view_source] A converter for typing.Any and object typed values, which will return them unchanged in any case.","title":"Class AnyConverter"},{"location":"api/databind.json.converters/#class-datetimeconverter","text":"class DatetimeConverter ( Converter ) [view_source] A converter for datetime.datetime , datetime.date and datetime.time that represents the serialized form as strings formatted using the nr.util.date module. The converter respects the DateFormat setting.","title":"Class DatetimeConverter"},{"location":"api/databind.json.converters/#class-decimalconverter","text":"class DecimalConverter ( Converter ) [view_source] A converter for decimal.Decimal values to and from JSON as strings.","title":"Class DecimalConverter"},{"location":"api/databind.json.converters/#class-enumconverter","text":"class EnumConverter ( Converter ) [view_source] JSON converter for enum values. Converts enum.IntEnum values to integers and enum.Enum values to strings. Note that combined integer flags are not supported and cannot be serializ Aliases on the type annotation of an enum field are considered as aliases for the field name to be used in the value's serialized form as opposed to its value name defined in code. Example : import enum , typing from databind.core.settings import Alias class Pet ( enum . Enum ): CAT = enum . auto () DOG = enum . auto () LION : typing . Annotated [ int , Alias ( 'KITTY' )] = enum . auto ()","title":"Class EnumConverter"},{"location":"api/databind.json.converters/#class-plaindatatypeconverter","text":"class PlainDatatypeConverter ( Converter ) [view_source] A converter for the plain datatypes bool , bytes , int , str and float . Arguments : direction Direction - The direction in which to convert (serialize or deserialize). strict_by_default bool - Whether to use strict type conversion on values by default if no other information on strictness is given. This defaults to True . With strict conversion enabled, loss-less type conversions are disabled (such as casting a string to an integer). Note that serialization is always strict, only the deserialization is controlled with this option or the Strict setting.","title":"Class PlainDatatypeConverter"},{"location":"api/databind.json.converters/#class-schemaconverter","text":"class SchemaConverter ( Converter ) [view_source] Converter for type hints that can be adapter to a databind.core.schema.Schema object. This converter respects the following settings: Alias SerializeDefaults","title":"Class SchemaConverter"},{"location":"api/databind.json.converters/#class-stringifyconverter","text":"class StringifyConverter ( Converter ) [view_source] A useful helper converter that matches on a given type or its subclasses and converts them to a string for serialization and deserializes them from a string using the type's constructor.","title":"Class StringifyConverter"},{"location":"api/databind.json.converters/#class-unionconverter","text":"class UnionConverter ( Converter ) [view_source] Converter for union types. The following kinds of union types are supported: A typing.Union (represented as typeapi.Union ) instance, in which case the members are deserialized in the the Union.NESTED mode, using the class name as the discriminator keys. AOrB = A | B # ex.: {\"type\": \"A\", \"A\": {...}} A typing.Annotated annotated with the Union setting (represented as typeapi.Annotated ) from databind.core.settings import Union AOrB = typing . Annotated [ A | B , Union ({ 'a' : A , 'b' : B }, Union . KEYED )] # ex.: {\"a\": {...}} A class that is decorated with the Union setting import dataclasses from databind.core.settings import Union @Union ( style = Union . FLAT ) class Base ( abc . ABC ): pass @Union . register ( Base , 'a' ) @dataclasses . dataclass class A ( Base ): pass # ... # ex.: {\"type\": \"a\", ...} Note Note that the union members should be concrete types, not generic aliases, because the converter cannot check if an object is an instance of an alias. This is an implementation detail of the databind.core.union.UnionMembers implementations. More Examples: import abc import typing from databind.core.settings import Union AOrB = typing . Annotated [ typing . Union [ A , B ], Union ({ 'A' : A , 'B' : B }, Union . NESTED , 'uses' , 'with' ) ] @Union ( '!my.package.plugins' ) class Plugin ( abc . ABC ): @abc . abstractmethod def activate ( self ) -> None : ...","title":"Class UnionConverter"},{"location":"api/databind.json.converters/#class-literalconverter","text":"class LiteralConverter ( Converter ) [view_source] A converter for typing.Literal type hints. A literal value in the definition must simply match the literal value in the context being serialized/deserialized, otherwise a ConversionError is raised. Currently, literal values must be of a plain data type that natively maps to a JSON type, like a boolean, integer, float, string or None .","title":"Class LiteralConverter"},{"location":"api/databind.json.direction/","text":"@pydoc databind.json.direction","title":"databind.json.direction"},{"location":"api/databind.json/","text":"The databind.json package implements the capabilities to bind JSON payloads to objects and the reverse.","title":"databind.json"},{"location":"api/databind.json.module/","text":"Class JsonModule class JsonModule ( Module ) [view_source] The JSON module combines all converters provided by the databind.json package in one usable module. The direction in which the converters should convert must be specified with the direction argument. Alternatively, use one of the convenience static methods serializing() and deserializing() .","title":"databind.json.module"},{"location":"api/databind.json.module/#class-jsonmodule","text":"class JsonModule ( Module ) [view_source] The JSON module combines all converters provided by the databind.json package in one usable module. The direction in which the converters should convert must be specified with the direction argument. Alternatively, use one of the convenience static methods serializing() and deserializing() .","title":"Class JsonModule"},{"location":"changelog/databind.core/","text":"3.0.0 (2022-11-05) Type Description PR Issues Author Breaking change add `Direction` as a concept to `databind.core` (previously only in `databind.json`) which can be imported from `databind.core.context` @NiklasRosenstein Feature add `Context.direction` member @NiklasRosenstein Feature add `ObjectMapper.serialize()` and `ObjectMapper.deserialize()` @NiklasRosenstein Breaking change remove `BiObjectMapper` class @NiklasRosenstein Breaking change add `direction` argument to `ObjectMapper.convert()` @NiklasRosenstein Feature add `Converter.serialize()` and `Converter.deserialize()`, add default implementation for `Converter.convert()` to dispatch to the respective member based on the `Context.direction` @NiklasRosenstein Breaking change `ObjectMapper` is now a generic with parameters `T` (the deserialized representation of the type) and `U` (the serialized representation of the type) @NiklasRosenstein Breaking change Change `ExtraKeys` setting signature from `(arg: bool | callable)` to `(allow: bool = True, recorder: callable | None = None)` @NiklasRosenstein 2.0.9 (2022-11-03) Type Description PR Issues Author Feature add `Module.get_converters()` @NiklasRosenstein 2.0.7 (2022-06-20) Type Description PR Issues Author Improvement Enable Mypy strict type checking mode @NiklasRosenstein 2.0.6 (2022-06-20) Type Description PR Issues Author Improvement Add support for `typeapi 0.2.0` @NiklasRosenstein 2.0.4 (2022-05-11) Type Description PR Issues Author Fix Fixed an issue where the frame for a dataclass type saved with `typeapi.scoped` was not respected for type evaluation. @NiklasRosenstein Fix Fixed module-scoped evaluation of forward references for subclasses of `typing.TypedDict`. @NiklasRosenstein 2.0.3 (2022-05-11) Type Description PR Issues Author Fix Fix resolving nested forward references in dataclasses. @NiklasRosenstein 2.0.2 (2022-05-11) Type Description PR Issues Author Docs Add URLs to project metadata. @NiklasRosenstein Improvement Schemas (dataclasses, typed dicts) that have an `Optional` field that are not explicitly marked as `Required()` now automatically get assigned `None` as a default value @NiklasRosenstein 2.0.1 (2022-05-09) Type Description PR Issues Author Improvement Loosen requirement on `typing-extensions` from `^3.10.0` to `>=3.10.0` @NiklasRosenstein Refactor Use Black and isort for code formatting, Flake8 for linting @NiklasRosenstein 2.0.0-alpha.4 (2022-03-29) Type Description PR Issues Author Fix Fix error in `ConversionError.expected()` if the `types` parameter was a type hint @NiklasRosenstein Breaking change add `ConversionError()` `origin` and `errors` parameter @NiklasRosenstein 2.0.0a2 (2022-03-24) Type Description PR Issues Author Improvement move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core` @NiklasRosenstein Feature make `ExtraKeys` setting a subclass of `ClassDecoratorSetting`, allowing it to be used to mark an entire class and allowing extra keys @NiklasRosenstein 1.5.2 (2022-03-23) Type Description PR Issues Author Feature add `nesting_key` parameter to `union()` annotation @NiklasRosenstein 1.5.1 (2022-02-26) Type Description PR Issues Author Refactor migrate to `nr.util` package @NiklasRosenstein 1.5.0 (2022-02-26) Type Description PR Issues Author Feature support resolution of type variables as they are encountered in unspecialized form NiklasRosenstein/databind#25 @NiklasRosenstein Fix fix `unpack_type_hints()` to return args for a parametrized special generic alias (like `typing.List[T]` returning `(list, (T,))`) @NiklasRosenstein 1.4.0 (2022-01-22) Type Description PR Issues Author Feature add `union.Style.keyed` NiklasRosenstein/databind#21 @NiklasRosenstein 1.3.2 (2022-01-10) Type Description PR Issues Author Fix make `databind.core.annotations` hashable for use in `typing.Annotations` @NiklasRosenstein 1.3.1 (2022-01-08) Type Description PR Issues Author Fix Dataclass adapted to ObjectType with no schema fields if a field cannot be adapted NiklasRosenstein/databind#23 @NiklasRosenstein Feature support resolving forward references in PEP585 generic aliases NiklasRosenstein/databind#24 @NiklasRosenstein Improvement change `ConverterProvider.get_converter()` to `ConverterProvider.get_converters()` and `ConversionNotApplicable` error type, allowing to test multiple converters for a type @NiklasRosenstein 1.3.0 (2022-01-06) Type Description PR Issues Author Improvement improve readability of `ConversionError` by changing `Location.format()` @NiklasRosenstein 1.2.6 (2021-12-29) Type Description PR Issues Author Fix correctly support Python 3.10 `types.UnionType` @NiklasRosenstein 1.2.5 (2021-10-24) Type Description PR Issues Author Fix add missing nr.pylang.utils dependency (was introduced transtively before so it was no crucial bug) @NiklasRosenstein 1.2.3 (2021-09-06) Type Description PR Issues Author Fix allow datetime objects as value during deserialization NiklasRosenstein/databind#19 @NiklasRosenstein 1.2.2 (2021-09-01) Type Description PR Issues Author Fix `DefaultTypeHintAdapter` no longer raises an exception upon receiving a BaseType instance @NiklasRosenstein Improvement `dataclass_to_schema(type_adapter)` argument is now optional and defaults to a `DefaultTypeHintAdapter` instance @NiklasRosenstein 1.2.0 (2021-08-20) Type Description PR Issues Author Feature add `Direction.is_serialize()` and `Direction.is_deserialize()` @NiklasRosenstein Feature add `AnnotationsRegistry.add_type_annotation()` and `AnnotationsRegistry.add_field_annotation()` @NiklasRosenstein Feature `DefaultAnnotationsProvider` now supports finding annotations in `Enum` members when annotated with `te.Annotated`, `DefaultAnnotationsProvider` is now registered to an `ObjectMapper` by default @NiklasRosenstein 1.1.6 (2021-08-18) Type Description PR Issues Author Fix fix case where DefaultTypeHintAdapter does not continue adaptation dynamically upon encountering a fixed type object @NiklasRosenstein 1.1.5 (2021-08-16) Type Description PR Issues Author Fix normal type with `Annotated[MyType, union(...)]` is now correctly interpreted as `UnionType` @NiklasRosenstein 1.1.3 (2021-08-10) Type Description PR Issues Author Improvement `ObjectType` and `ConcreteType` now show the class fqn on repr() @NiklasRosenstein Fix fix support for special generic subclasses (like `List` or `Dict`) with another generic base class (eg. `Generic`) @NiklasRosenstein 1.1.2 (2021-08-06) Type Description PR Issues Author Fix fix `@A.union` types to accept `ObjectType`s @NiklasRosenstein 1.1.1 (2021-08-03) Type Description PR Issues Author Fix fix `EntrypointSubtypes()` constructor which used to accidentally accept a `TypeHintAdapter` argument @NiklasRosenstein 1.1.0 (2021-08-03) Type Description PR Issues Author Improvement remove `AnnotatedType`, add `BaseType.annotations` instead. @NiklasRosenstein Breaking change Reorganize a lot of internal APIs and some public APIs (e.g. renamed `ITypeHintConverter` to `TypeHintAdapter`, `IConverter` to `Converter` + respective module name changes, deprecated `ObjectMapper.default()`, remove `IObjectMapper` and replace `Context.mapper` with `Context.converters` and `Context.annotations`. @NiklasRosenstein Breaking change replace `Schema.flat_fields()` with `Schema.flattened()` @NiklasRosenstein Improvement only import members from sub-modules where they are expected to be used from (ie. `databind.core`, `databind.core.annotations`, `databind.core.dataclasses`, `databind.json`) @NiklasRosenstein Feature add support for `fieldinfo(flat=True)` marked `MapType` fields NiklasRosenstein/databind#7 @NiklasRosenstein 1.0.1 (2021-07-23) Type Description PR Issues Author Improvement import `dataclass_to_schema` into `databind.core` top-level package @NiklasRosenstein Fix fix type hints to pass mypy checks @NiklasRosenstein 1.0.0 (2021-07-20) Type Description PR Issues Author Breaking change Full rewrite @NiklasRosenstein 0.11.0 (2021-04-08) Type Description PR Issues Author Feature `enumerate_fields()` now works with uniontype instances and classes @NiklasRosenstein Improvement update `@uniontype` generated `__repr__()` method @NiklasRosenstein Feature add support for member aliasing in `UnionResolver` @NiklasRosenstein Feature add `Context.closed_field_metadata()` function @NiklasRosenstein 0.10.0 (2021-03-05) Type Description PR Issues Author Improvement classes decorated with `@uniontype(container=True)` must now be constructed using a single keyword argument as in `MyUnion(member1=Member1Value())` @NiklasRosenstein 0.9.0 (2020-12-30) Type Description PR Issues Author Feature add `ImportingUnionResolver` and `EntrypointUnionResolver`, both which can also be used with the `@interface` decorator. The `resolver` argument now accepts a string which will be converted into a `UnionResolver` (supported formats are `import` and `entrypoint: `) @NiklasRosenstein Fix `@implementation()` can now be used without explicitly specifying the `for_` parameter when decorating a class with multiple bases where only one base is a `@uniontype` @NiklasRosenstein Fix fix inheritance of fields from `@dataclass` parent classes @NiklasRosenstein 0.8.0 (2020-11-24) Type Description PR Issues Author Improvement `@implementation()` now sets the databind metadata field to `None` if no explicit metadata is already set on the type. `Registry.get_converter()` recognizes this case and stops checking the base classes. This is to avoid a confusing error when the type decorated with `@implementation()` seems to inherit the `UnionMetadata` from the parent class (because of the `Registry.get_converter()` base class check) but actually does not provide a metadata. Now we see \"no converter found for type XYZ\" instead \"expected UnionMetadata to be provided by XYZ\" in `databind.json` @NiklasRosenstein 0.7.1 (2020-11-20) Type Description PR Issues Author Fix Python 3.9 support in type hint normalization @NiklasRosenstein Fix fix mypy errors @NiklasRosenstein 0.7.0 (2020-10-02) Type Description PR Issues Author Feature `@dataclasses.dataclass()` classes can now be converted as a data model automatically, `BaseMetadata.for_type()` now returns an optional @NiklasRosenstein 0.6.0 (2020-09-14) Type Description PR Issues Author Fix `Registry.get_converter()` now looks for a converter in the base classes only if it could not find it for the normalized version of the current type, making converter resolution more predictable @NiklasRosenstein Feature Add `ClassUnionResolver` which evaluates type hints dynamically, allowing to use forward references in the type hints of a `@uniontype()` @NiklasRosenstein Feature Add `@interface()` and `@implementation()` decorators @NiklasRosenstein 0.5.0 (2020-09-10) Type Description PR Issues Author 0.4.2 (2020-09-09) Type Description PR Issues Author Hygiene Move `type_repr()` declaration to `databind.core.utils` and add `find_orig_base()` function @NiklasRosenstein 0.4.1 (2020-09-08) Type Description PR Issues Author Fix Re-render setup file, materializing missing dependency on `dataclasses`. This fixes using the module in Python 3.6. @NiklasRosenstein 0.4.0 (2020-09-06) Type Description PR Issues Author Feature add `ModelMetadata.serialize_as` (which translates into a keyword argument for `@datamodel()`) to specify a type hint that should be used instead of the type itself when serializing/deserializing it @NiklasRosenstein Feature add `Context.coerce_errors()` context manager @NiklasRosenstein Feature add `TypeHint` variable which should be used in places where a type hint is expected @NiklasRosenstein 0.3.0 (2020-08-29) Type Description PR Issues Author Improvement ensure that non-default arguments do not have a class attribute of type `object` (which is used as a workaround to support non-default fields following default fields in `dataclasses`) @NiklasRosenstein Fix raise for uninitialized fields inherited from parent datamodels @NiklasRosenstein 0.2.0 (2020-08-29) Type Description PR Issues Author Improvement update type hints to pass mypy checks @NiklasRosenstein Improvement `FieldMetadata` now keeps a reference to the `dataclasses.Field` object and it's' metadata @NiklasRosenstein","title":"databind.core"},{"location":"changelog/databind.core/#300-2022-11-05","text":"Type Description PR Issues Author Breaking change add `Direction` as a concept to `databind.core` (previously only in `databind.json`) which can be imported from `databind.core.context` @NiklasRosenstein Feature add `Context.direction` member @NiklasRosenstein Feature add `ObjectMapper.serialize()` and `ObjectMapper.deserialize()` @NiklasRosenstein Breaking change remove `BiObjectMapper` class @NiklasRosenstein Breaking change add `direction` argument to `ObjectMapper.convert()` @NiklasRosenstein Feature add `Converter.serialize()` and `Converter.deserialize()`, add default implementation for `Converter.convert()` to dispatch to the respective member based on the `Context.direction` @NiklasRosenstein Breaking change `ObjectMapper` is now a generic with parameters `T` (the deserialized representation of the type) and `U` (the serialized representation of the type) @NiklasRosenstein Breaking change Change `ExtraKeys` setting signature from `(arg: bool | callable)` to `(allow: bool = True, recorder: callable | None = None)` @NiklasRosenstein","title":"3.0.0 (2022-11-05)"},{"location":"changelog/databind.core/#209-2022-11-03","text":"Type Description PR Issues Author Feature add `Module.get_converters()` @NiklasRosenstein","title":"2.0.9 (2022-11-03)"},{"location":"changelog/databind.core/#207-2022-06-20","text":"Type Description PR Issues Author Improvement Enable Mypy strict type checking mode @NiklasRosenstein","title":"2.0.7 (2022-06-20)"},{"location":"changelog/databind.core/#206-2022-06-20","text":"Type Description PR Issues Author Improvement Add support for `typeapi 0.2.0` @NiklasRosenstein","title":"2.0.6 (2022-06-20)"},{"location":"changelog/databind.core/#204-2022-05-11","text":"Type Description PR Issues Author Fix Fixed an issue where the frame for a dataclass type saved with `typeapi.scoped` was not respected for type evaluation. @NiklasRosenstein Fix Fixed module-scoped evaluation of forward references for subclasses of `typing.TypedDict`. @NiklasRosenstein","title":"2.0.4 (2022-05-11)"},{"location":"changelog/databind.core/#203-2022-05-11","text":"Type Description PR Issues Author Fix Fix resolving nested forward references in dataclasses. @NiklasRosenstein","title":"2.0.3 (2022-05-11)"},{"location":"changelog/databind.core/#202-2022-05-11","text":"Type Description PR Issues Author Docs Add URLs to project metadata. @NiklasRosenstein Improvement Schemas (dataclasses, typed dicts) that have an `Optional` field that are not explicitly marked as `Required()` now automatically get assigned `None` as a default value @NiklasRosenstein","title":"2.0.2 (2022-05-11)"},{"location":"changelog/databind.core/#201-2022-05-09","text":"Type Description PR Issues Author Improvement Loosen requirement on `typing-extensions` from `^3.10.0` to `>=3.10.0` @NiklasRosenstein Refactor Use Black and isort for code formatting, Flake8 for linting @NiklasRosenstein","title":"2.0.1 (2022-05-09)"},{"location":"changelog/databind.core/#200-alpha4-2022-03-29","text":"Type Description PR Issues Author Fix Fix error in `ConversionError.expected()` if the `types` parameter was a type hint @NiklasRosenstein Breaking change add `ConversionError()` `origin` and `errors` parameter @NiklasRosenstein","title":"2.0.0-alpha.4 (2022-03-29)"},{"location":"changelog/databind.core/#200a2-2022-03-24","text":"Type Description PR Issues Author Improvement move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core` @NiklasRosenstein Feature make `ExtraKeys` setting a subclass of `ClassDecoratorSetting`, allowing it to be used to mark an entire class and allowing extra keys @NiklasRosenstein","title":"2.0.0a2 (2022-03-24)"},{"location":"changelog/databind.core/#152-2022-03-23","text":"Type Description PR Issues Author Feature add `nesting_key` parameter to `union()` annotation @NiklasRosenstein","title":"1.5.2 (2022-03-23)"},{"location":"changelog/databind.core/#151-2022-02-26","text":"Type Description PR Issues Author Refactor migrate to `nr.util` package @NiklasRosenstein","title":"1.5.1 (2022-02-26)"},{"location":"changelog/databind.core/#150-2022-02-26","text":"Type Description PR Issues Author Feature support resolution of type variables as they are encountered in unspecialized form NiklasRosenstein/databind#25 @NiklasRosenstein Fix fix `unpack_type_hints()` to return args for a parametrized special generic alias (like `typing.List[T]` returning `(list, (T,))`) @NiklasRosenstein","title":"1.5.0 (2022-02-26)"},{"location":"changelog/databind.core/#140-2022-01-22","text":"Type Description PR Issues Author Feature add `union.Style.keyed` NiklasRosenstein/databind#21 @NiklasRosenstein","title":"1.4.0 (2022-01-22)"},{"location":"changelog/databind.core/#132-2022-01-10","text":"Type Description PR Issues Author Fix make `databind.core.annotations` hashable for use in `typing.Annotations` @NiklasRosenstein","title":"1.3.2 (2022-01-10)"},{"location":"changelog/databind.core/#131-2022-01-08","text":"Type Description PR Issues Author Fix Dataclass adapted to ObjectType with no schema fields if a field cannot be adapted NiklasRosenstein/databind#23 @NiklasRosenstein Feature support resolving forward references in PEP585 generic aliases NiklasRosenstein/databind#24 @NiklasRosenstein Improvement change `ConverterProvider.get_converter()` to `ConverterProvider.get_converters()` and `ConversionNotApplicable` error type, allowing to test multiple converters for a type @NiklasRosenstein","title":"1.3.1 (2022-01-08)"},{"location":"changelog/databind.core/#130-2022-01-06","text":"Type Description PR Issues Author Improvement improve readability of `ConversionError` by changing `Location.format()` @NiklasRosenstein","title":"1.3.0 (2022-01-06)"},{"location":"changelog/databind.core/#126-2021-12-29","text":"Type Description PR Issues Author Fix correctly support Python 3.10 `types.UnionType` @NiklasRosenstein","title":"1.2.6 (2021-12-29)"},{"location":"changelog/databind.core/#125-2021-10-24","text":"Type Description PR Issues Author Fix add missing nr.pylang.utils dependency (was introduced transtively before so it was no crucial bug) @NiklasRosenstein","title":"1.2.5 (2021-10-24)"},{"location":"changelog/databind.core/#123-2021-09-06","text":"Type Description PR Issues Author Fix allow datetime objects as value during deserialization NiklasRosenstein/databind#19 @NiklasRosenstein","title":"1.2.3 (2021-09-06)"},{"location":"changelog/databind.core/#122-2021-09-01","text":"Type Description PR Issues Author Fix `DefaultTypeHintAdapter` no longer raises an exception upon receiving a BaseType instance @NiklasRosenstein Improvement `dataclass_to_schema(type_adapter)` argument is now optional and defaults to a `DefaultTypeHintAdapter` instance @NiklasRosenstein","title":"1.2.2 (2021-09-01)"},{"location":"changelog/databind.core/#120-2021-08-20","text":"Type Description PR Issues Author Feature add `Direction.is_serialize()` and `Direction.is_deserialize()` @NiklasRosenstein Feature add `AnnotationsRegistry.add_type_annotation()` and `AnnotationsRegistry.add_field_annotation()` @NiklasRosenstein Feature `DefaultAnnotationsProvider` now supports finding annotations in `Enum` members when annotated with `te.Annotated`, `DefaultAnnotationsProvider` is now registered to an `ObjectMapper` by default @NiklasRosenstein","title":"1.2.0 (2021-08-20)"},{"location":"changelog/databind.core/#116-2021-08-18","text":"Type Description PR Issues Author Fix fix case where DefaultTypeHintAdapter does not continue adaptation dynamically upon encountering a fixed type object @NiklasRosenstein","title":"1.1.6 (2021-08-18)"},{"location":"changelog/databind.core/#115-2021-08-16","text":"Type Description PR Issues Author Fix normal type with `Annotated[MyType, union(...)]` is now correctly interpreted as `UnionType` @NiklasRosenstein","title":"1.1.5 (2021-08-16)"},{"location":"changelog/databind.core/#113-2021-08-10","text":"Type Description PR Issues Author Improvement `ObjectType` and `ConcreteType` now show the class fqn on repr() @NiklasRosenstein Fix fix support for special generic subclasses (like `List` or `Dict`) with another generic base class (eg. `Generic`) @NiklasRosenstein","title":"1.1.3 (2021-08-10)"},{"location":"changelog/databind.core/#112-2021-08-06","text":"Type Description PR Issues Author Fix fix `@A.union` types to accept `ObjectType`s @NiklasRosenstein","title":"1.1.2 (2021-08-06)"},{"location":"changelog/databind.core/#111-2021-08-03","text":"Type Description PR Issues Author Fix fix `EntrypointSubtypes()` constructor which used to accidentally accept a `TypeHintAdapter` argument @NiklasRosenstein","title":"1.1.1 (2021-08-03)"},{"location":"changelog/databind.core/#110-2021-08-03","text":"Type Description PR Issues Author Improvement remove `AnnotatedType`, add `BaseType.annotations` instead. @NiklasRosenstein Breaking change Reorganize a lot of internal APIs and some public APIs (e.g. renamed `ITypeHintConverter` to `TypeHintAdapter`, `IConverter` to `Converter` + respective module name changes, deprecated `ObjectMapper.default()`, remove `IObjectMapper` and replace `Context.mapper` with `Context.converters` and `Context.annotations`. @NiklasRosenstein Breaking change replace `Schema.flat_fields()` with `Schema.flattened()` @NiklasRosenstein Improvement only import members from sub-modules where they are expected to be used from (ie. `databind.core`, `databind.core.annotations`, `databind.core.dataclasses`, `databind.json`) @NiklasRosenstein Feature add support for `fieldinfo(flat=True)` marked `MapType` fields NiklasRosenstein/databind#7 @NiklasRosenstein","title":"1.1.0 (2021-08-03)"},{"location":"changelog/databind.core/#101-2021-07-23","text":"Type Description PR Issues Author Improvement import `dataclass_to_schema` into `databind.core` top-level package @NiklasRosenstein Fix fix type hints to pass mypy checks @NiklasRosenstein","title":"1.0.1 (2021-07-23)"},{"location":"changelog/databind.core/#100-2021-07-20","text":"Type Description PR Issues Author Breaking change Full rewrite @NiklasRosenstein","title":"1.0.0 (2021-07-20)"},{"location":"changelog/databind.core/#0110-2021-04-08","text":"Type Description PR Issues Author Feature `enumerate_fields()` now works with uniontype instances and classes @NiklasRosenstein Improvement update `@uniontype` generated `__repr__()` method @NiklasRosenstein Feature add support for member aliasing in `UnionResolver` @NiklasRosenstein Feature add `Context.closed_field_metadata()` function @NiklasRosenstein","title":"0.11.0 (2021-04-08)"},{"location":"changelog/databind.core/#0100-2021-03-05","text":"Type Description PR Issues Author Improvement classes decorated with `@uniontype(container=True)` must now be constructed using a single keyword argument as in `MyUnion(member1=Member1Value())` @NiklasRosenstein","title":"0.10.0 (2021-03-05)"},{"location":"changelog/databind.core/#090-2020-12-30","text":"Type Description PR Issues Author Feature add `ImportingUnionResolver` and `EntrypointUnionResolver`, both which can also be used with the `@interface` decorator. The `resolver` argument now accepts a string which will be converted into a `UnionResolver` (supported formats are `import` and `entrypoint: `) @NiklasRosenstein Fix `@implementation()` can now be used without explicitly specifying the `for_` parameter when decorating a class with multiple bases where only one base is a `@uniontype` @NiklasRosenstein Fix fix inheritance of fields from `@dataclass` parent classes @NiklasRosenstein","title":"0.9.0 (2020-12-30)"},{"location":"changelog/databind.core/#080-2020-11-24","text":"Type Description PR Issues Author Improvement `@implementation()` now sets the databind metadata field to `None` if no explicit metadata is already set on the type. `Registry.get_converter()` recognizes this case and stops checking the base classes. This is to avoid a confusing error when the type decorated with `@implementation()` seems to inherit the `UnionMetadata` from the parent class (because of the `Registry.get_converter()` base class check) but actually does not provide a metadata. Now we see \"no converter found for type XYZ\" instead \"expected UnionMetadata to be provided by XYZ\" in `databind.json` @NiklasRosenstein","title":"0.8.0 (2020-11-24)"},{"location":"changelog/databind.core/#071-2020-11-20","text":"Type Description PR Issues Author Fix Python 3.9 support in type hint normalization @NiklasRosenstein Fix fix mypy errors @NiklasRosenstein","title":"0.7.1 (2020-11-20)"},{"location":"changelog/databind.core/#070-2020-10-02","text":"Type Description PR Issues Author Feature `@dataclasses.dataclass()` classes can now be converted as a data model automatically, `BaseMetadata.for_type()` now returns an optional @NiklasRosenstein","title":"0.7.0 (2020-10-02)"},{"location":"changelog/databind.core/#060-2020-09-14","text":"Type Description PR Issues Author Fix `Registry.get_converter()` now looks for a converter in the base classes only if it could not find it for the normalized version of the current type, making converter resolution more predictable @NiklasRosenstein Feature Add `ClassUnionResolver` which evaluates type hints dynamically, allowing to use forward references in the type hints of a `@uniontype()` @NiklasRosenstein Feature Add `@interface()` and `@implementation()` decorators @NiklasRosenstein","title":"0.6.0 (2020-09-14)"},{"location":"changelog/databind.core/#050-2020-09-10","text":"Type Description PR Issues Author","title":"0.5.0 (2020-09-10)"},{"location":"changelog/databind.core/#042-2020-09-09","text":"Type Description PR Issues Author Hygiene Move `type_repr()` declaration to `databind.core.utils` and add `find_orig_base()` function @NiklasRosenstein","title":"0.4.2 (2020-09-09)"},{"location":"changelog/databind.core/#041-2020-09-08","text":"Type Description PR Issues Author Fix Re-render setup file, materializing missing dependency on `dataclasses`. This fixes using the module in Python 3.6. @NiklasRosenstein","title":"0.4.1 (2020-09-08)"},{"location":"changelog/databind.core/#040-2020-09-06","text":"Type Description PR Issues Author Feature add `ModelMetadata.serialize_as` (which translates into a keyword argument for `@datamodel()`) to specify a type hint that should be used instead of the type itself when serializing/deserializing it @NiklasRosenstein Feature add `Context.coerce_errors()` context manager @NiklasRosenstein Feature add `TypeHint` variable which should be used in places where a type hint is expected @NiklasRosenstein","title":"0.4.0 (2020-09-06)"},{"location":"changelog/databind.core/#030-2020-08-29","text":"Type Description PR Issues Author Improvement ensure that non-default arguments do not have a class attribute of type `object` (which is used as a workaround to support non-default fields following default fields in `dataclasses`) @NiklasRosenstein Fix raise for uninitialized fields inherited from parent datamodels @NiklasRosenstein","title":"0.3.0 (2020-08-29)"},{"location":"changelog/databind.core/#020-2020-08-29","text":"Type Description PR Issues Author Improvement update type hints to pass mypy checks @NiklasRosenstein Improvement `FieldMetadata` now keeps a reference to the `dataclasses.Field` object and it's' metadata @NiklasRosenstein","title":"0.2.0 (2020-08-29)"},{"location":"changelog/databind.json/","text":"3.0.0 (2022-11-05) Type Description PR Issues Author Docs add Examples page to docs @NiklasRosenstein Breaking change remove `get_bimapper()` and replace it with `get_object_mapper()` @NiklasRosenstein Breaking change remove `Direction` concept from this package as it is now part of `databind.core`, removed it from `JsonModule` and all `Converter` implementations @NiklasRosenstein 2.0.9 (2022-11-03) Type Description PR Issues Author Feature add `JsonConverter()` setting to override the converter used for JSON de-/serialization @NiklasRosenstein 2.0.8 (2022-09-27) Type Description PR Issues Author Improvement Add a `LiteralConverter` which allows you to create literal-based unions (see new example in readme) @NiklasRosenstein 2.0.7 (2022-06-20) Type Description PR Issues Author Improvement Enable Mypy strict type checking mode @NiklasRosenstein 2.0.5 (2022-06-16) Type Description PR Issues Author Fix Fix that subclasses of a dataclasses marked also with @Union are deserialized as dataclasses instead of Unions; this change may have wider reaching effects because we no longer look up settings in bases of a type, but unit tests are OK with this @NiklasRosenstein 2.0.3 (2022-05-11) Type Description PR Issues Author Fix Fixed an issue when deserializing fields in a schema when the Python type does not have the exact same representation in the structured payload, causing an error when that Python default value is handed as a value to be deserialized. @NiklasRosenstein 2.0.2 (2022-05-11) Type Description PR Issues Author Docs Add URLs to project metadata. @NiklasRosenstein Improvement Use a fields default value if it is available when deserializing schemas @NiklasRosenstein 2.0.1 (2022-05-09) Type Description PR Issues Author Improvement Loosen requirement on `typing-extensions` from `^3.10.0` to `>=3.10.0` @NiklasRosenstein Refactor Use Black and isort for code formatting, Flake8 for linting @NiklasRosenstein 2.0.0 (2022-03-31) Type Description PR Issues Author Breaking change Remove `databind.json.settings` module @NiklasRosenstein 2.0.0-alpha.4 (2022-03-29) Type Description PR Issues Author Breaking change implement `Union.BEST_MATCH` in `UnionConverter`, which is now used as the default if an un-annotated `typing.Union` is encountered @NiklasRosenstein 2.0.0a3 (2022-03-29) Type Description PR Issues Author Fix Fix `CollectionConverter` (used for subclasses of `collections.abc.Collection`) does not end up returnin a generator instead of a collection @NiklasRosenstein 2.0.0a2 (2022-03-24) Type Description PR Issues Author Improvement move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core` @NiklasRosenstein 1.5.1 (2022-02-26) Type Description PR Issues Author Refactor migrate to `nr.util` package @NiklasRosenstein 1.4.0 (2022-01-22) Type Description PR Issues Author Feature support `union.Style.keyed` NiklasRosenstein/databind#21 @NiklasRosenstein 1.3.1 (2022-01-08) Type Description PR Issues Author Feature add `databind.json.annotations.with_custom_json_converter()` annotation to allow implementing a custom converter for dataclasses @NiklasRosenstein Fix narrow `JsonType` union type to use `dict` and `list` instead of `t.Mapping` and `t.Collection` NiklasRosenstein/databind#22 @NiklasRosenstein 1.2.4 (2021-10-24) Type Description PR Issues Author Fix declare missing `nr.optional` dependency (was not an actual bug because the dependency was introduced transitively anyway) @NiklasRosenstein 1.2.0 (2021-08-20) Type Description PR Issues Author Feature add converter for `pathlib.PurePath` subclasses, enabled in the `JsonModule` by default NiklasRosenstein/databind#14 @NiklasRosenstein Feature add converter for `uuid.UUID` to `JsonModule` NiklasRosenstein/databind#15 @NiklasRosenstein Feature support aliases on enum values NiklasRosenstein/databind#1 @NiklasRosenstein 1.1.5 (2021-08-16) Type Description PR Issues Author Fix `str`, `bytes`, `bytearray` and `memoryview` are no longer accepted when deserializing `CollectionType` values NiklasRosenstein/databind#13 @NiklasRosenstein 1.1.2 (2021-08-06) Type Description PR Issues Author Feature support de-/serializing `bytes` as base64 @NiklasRosenstein 0.12.0 (2021-04-08) Type Description PR Issues Author Feature Add `uniontype(single_key_discriminator)` argument @NiklasRosenstein Fix Generated `__eq__()` method for `uniontype(container=True)` is now injective to avoid issue when `type(other)` is `object` @NiklasRosenstein Feature add support for aliasing with `field(altname)` in `@uniontype` container declarations @NiklasRosenstein Feature `StringConverter` can now also be relaxed, `FieldMetadata.relaxed` is now inherited from the closest metadata in the context for POD data types @NiklasRosenstein Fix deserializing a `List[str]` from a `str` object now results in an error @NiklasRosenstein Improvement bump dependency on databind.core to ^0.11.0 @NiklasRosenstein 0.11.0 (2021-03-05) Type Description PR Issues Author Improvement Update union construction during deserialization @NiklasRosenstein Improvement minimum version of `databind.core` is `^0.10.0` @NiklasRosenstein 0.10.0 (2020-12-30) Type Description PR Issues Author Fix add missing `to_stream` and `from_stream` to `__all__` @NiklasRosenstein Feature add `cast()` function @NiklasRosenstein 0.9.0 (2020-11-24) Type Description PR Issues Author Feature handle `FieldMetadata.relaxed` and `FieldMetadata.strict` in Bool, Integer and String converters @NiklasRosenstein 0.8.0 (2020-11-24) Type Description PR Issues Author Feature add converter for `typing.Any`, which by the way does not actually convert anything @NiklasRosenstein 0.7.1 (2020-11-20) Type Description PR Issues Author Fix Fix mypy errors @NiklasRosenstein 0.7.0 (2020-10-02) Type Description PR Issues Author Feature Now supports converting Sets @NiklasRosenstein 0.6.1 (2020-09-10) Type Description PR Issues Author Fix Fix `NameError` in `ObjectConverter` @NiklasRosenstein 0.6.0 (2020-09-10) Type Description PR Issues Author Feature Add `to_stream()` and `from_stream()` functions @NiklasRosenstein Feature Add support for `typing.Dict` subclasses @NiklasRosenstein 0.5.1 (2020-09-09) Type Description PR Issues Author Fix Fix Python 3.6 support for `typing.List` subclasses by reading the generic paraemter from the right object @NiklasRosenstein 0.5.0 (2020-09-06) Type Description PR Issues Author Feature Add `strict` argument to `register_json_converters()` which will allow converters for plain-old-datatypes to accept string representations as well @NiklasRosenstein 0.4.1 (2020-09-06) Type Description PR Issues Author Fix conversion of values of a `List` subtype *from Python* are now converted to a built-in `list` instead of the same `List` subtype @NiklasRosenstein 0.4.0 (2020-09-06) Type Description PR Issues Author Feature support `@datamodel(serialize_as)` in `ModelConverter` @NiklasRosenstein 0.3.0 (2020-08-29) Type Description PR Issues Author Improvement `ArrayConverter` now supports subclasses of the `typing.List` generic @NiklasRosenstein 0.2.0 (2020-08-29) Type Description PR Issues Author Improvement update type hints to pass mypy checks @NiklasRosenstein Improvement add DEBUG log when `MixtypeConverter` is unable to convert a value at all to make debugging easier @NiklasRosenstein Fix accept `datetime.date`/`datetime.datetime` objects when converting to python if the target type is a respective match (rather than forcing a string as an input) @NiklasRosenstein","title":"databind.json"},{"location":"changelog/databind.json/#300-2022-11-05","text":"Type Description PR Issues Author Docs add Examples page to docs @NiklasRosenstein Breaking change remove `get_bimapper()` and replace it with `get_object_mapper()` @NiklasRosenstein Breaking change remove `Direction` concept from this package as it is now part of `databind.core`, removed it from `JsonModule` and all `Converter` implementations @NiklasRosenstein","title":"3.0.0 (2022-11-05)"},{"location":"changelog/databind.json/#209-2022-11-03","text":"Type Description PR Issues Author Feature add `JsonConverter()` setting to override the converter used for JSON de-/serialization @NiklasRosenstein","title":"2.0.9 (2022-11-03)"},{"location":"changelog/databind.json/#208-2022-09-27","text":"Type Description PR Issues Author Improvement Add a `LiteralConverter` which allows you to create literal-based unions (see new example in readme) @NiklasRosenstein","title":"2.0.8 (2022-09-27)"},{"location":"changelog/databind.json/#207-2022-06-20","text":"Type Description PR Issues Author Improvement Enable Mypy strict type checking mode @NiklasRosenstein","title":"2.0.7 (2022-06-20)"},{"location":"changelog/databind.json/#205-2022-06-16","text":"Type Description PR Issues Author Fix Fix that subclasses of a dataclasses marked also with @Union are deserialized as dataclasses instead of Unions; this change may have wider reaching effects because we no longer look up settings in bases of a type, but unit tests are OK with this @NiklasRosenstein","title":"2.0.5 (2022-06-16)"},{"location":"changelog/databind.json/#203-2022-05-11","text":"Type Description PR Issues Author Fix Fixed an issue when deserializing fields in a schema when the Python type does not have the exact same representation in the structured payload, causing an error when that Python default value is handed as a value to be deserialized. @NiklasRosenstein","title":"2.0.3 (2022-05-11)"},{"location":"changelog/databind.json/#202-2022-05-11","text":"Type Description PR Issues Author Docs Add URLs to project metadata. @NiklasRosenstein Improvement Use a fields default value if it is available when deserializing schemas @NiklasRosenstein","title":"2.0.2 (2022-05-11)"},{"location":"changelog/databind.json/#201-2022-05-09","text":"Type Description PR Issues Author Improvement Loosen requirement on `typing-extensions` from `^3.10.0` to `>=3.10.0` @NiklasRosenstein Refactor Use Black and isort for code formatting, Flake8 for linting @NiklasRosenstein","title":"2.0.1 (2022-05-09)"},{"location":"changelog/databind.json/#200-2022-03-31","text":"Type Description PR Issues Author Breaking change Remove `databind.json.settings` module @NiklasRosenstein","title":"2.0.0 (2022-03-31)"},{"location":"changelog/databind.json/#200-alpha4-2022-03-29","text":"Type Description PR Issues Author Breaking change implement `Union.BEST_MATCH` in `UnionConverter`, which is now used as the default if an un-annotated `typing.Union` is encountered @NiklasRosenstein","title":"2.0.0-alpha.4 (2022-03-29)"},{"location":"changelog/databind.json/#200a3-2022-03-29","text":"Type Description PR Issues Author Fix Fix `CollectionConverter` (used for subclasses of `collections.abc.Collection`) does not end up returnin a generator instead of a collection @NiklasRosenstein","title":"2.0.0a3 (2022-03-29)"},{"location":"changelog/databind.json/#200a2-2022-03-24","text":"Type Description PR Issues Author Improvement move `ExtraKeys` and `Remainder` setting from `databind.json` to `databind.core` @NiklasRosenstein","title":"2.0.0a2 (2022-03-24)"},{"location":"changelog/databind.json/#151-2022-02-26","text":"Type Description PR Issues Author Refactor migrate to `nr.util` package @NiklasRosenstein","title":"1.5.1 (2022-02-26)"},{"location":"changelog/databind.json/#140-2022-01-22","text":"Type Description PR Issues Author Feature support `union.Style.keyed` NiklasRosenstein/databind#21 @NiklasRosenstein","title":"1.4.0 (2022-01-22)"},{"location":"changelog/databind.json/#131-2022-01-08","text":"Type Description PR Issues Author Feature add `databind.json.annotations.with_custom_json_converter()` annotation to allow implementing a custom converter for dataclasses @NiklasRosenstein Fix narrow `JsonType` union type to use `dict` and `list` instead of `t.Mapping` and `t.Collection` NiklasRosenstein/databind#22 @NiklasRosenstein","title":"1.3.1 (2022-01-08)"},{"location":"changelog/databind.json/#124-2021-10-24","text":"Type Description PR Issues Author Fix declare missing `nr.optional` dependency (was not an actual bug because the dependency was introduced transitively anyway) @NiklasRosenstein","title":"1.2.4 (2021-10-24)"},{"location":"changelog/databind.json/#120-2021-08-20","text":"Type Description PR Issues Author Feature add converter for `pathlib.PurePath` subclasses, enabled in the `JsonModule` by default NiklasRosenstein/databind#14 @NiklasRosenstein Feature add converter for `uuid.UUID` to `JsonModule` NiklasRosenstein/databind#15 @NiklasRosenstein Feature support aliases on enum values NiklasRosenstein/databind#1 @NiklasRosenstein","title":"1.2.0 (2021-08-20)"},{"location":"changelog/databind.json/#115-2021-08-16","text":"Type Description PR Issues Author Fix `str`, `bytes`, `bytearray` and `memoryview` are no longer accepted when deserializing `CollectionType` values NiklasRosenstein/databind#13 @NiklasRosenstein","title":"1.1.5 (2021-08-16)"},{"location":"changelog/databind.json/#112-2021-08-06","text":"Type Description PR Issues Author Feature support de-/serializing `bytes` as base64 @NiklasRosenstein","title":"1.1.2 (2021-08-06)"},{"location":"changelog/databind.json/#0120-2021-04-08","text":"Type Description PR Issues Author Feature Add `uniontype(single_key_discriminator)` argument @NiklasRosenstein Fix Generated `__eq__()` method for `uniontype(container=True)` is now injective to avoid issue when `type(other)` is `object` @NiklasRosenstein Feature add support for aliasing with `field(altname)` in `@uniontype` container declarations @NiklasRosenstein Feature `StringConverter` can now also be relaxed, `FieldMetadata.relaxed` is now inherited from the closest metadata in the context for POD data types @NiklasRosenstein Fix deserializing a `List[str]` from a `str` object now results in an error @NiklasRosenstein Improvement bump dependency on databind.core to ^0.11.0 @NiklasRosenstein","title":"0.12.0 (2021-04-08)"},{"location":"changelog/databind.json/#0110-2021-03-05","text":"Type Description PR Issues Author Improvement Update union construction during deserialization @NiklasRosenstein Improvement minimum version of `databind.core` is `^0.10.0` @NiklasRosenstein","title":"0.11.0 (2021-03-05)"},{"location":"changelog/databind.json/#0100-2020-12-30","text":"Type Description PR Issues Author Fix add missing `to_stream` and `from_stream` to `__all__` @NiklasRosenstein Feature add `cast()` function @NiklasRosenstein","title":"0.10.0 (2020-12-30)"},{"location":"changelog/databind.json/#090-2020-11-24","text":"Type Description PR Issues Author Feature handle `FieldMetadata.relaxed` and `FieldMetadata.strict` in Bool, Integer and String converters @NiklasRosenstein","title":"0.9.0 (2020-11-24)"},{"location":"changelog/databind.json/#080-2020-11-24","text":"Type Description PR Issues Author Feature add converter for `typing.Any`, which by the way does not actually convert anything @NiklasRosenstein","title":"0.8.0 (2020-11-24)"},{"location":"changelog/databind.json/#071-2020-11-20","text":"Type Description PR Issues Author Fix Fix mypy errors @NiklasRosenstein","title":"0.7.1 (2020-11-20)"},{"location":"changelog/databind.json/#070-2020-10-02","text":"Type Description PR Issues Author Feature Now supports converting Sets @NiklasRosenstein","title":"0.7.0 (2020-10-02)"},{"location":"changelog/databind.json/#061-2020-09-10","text":"Type Description PR Issues Author Fix Fix `NameError` in `ObjectConverter` @NiklasRosenstein","title":"0.6.1 (2020-09-10)"},{"location":"changelog/databind.json/#060-2020-09-10","text":"Type Description PR Issues Author Feature Add `to_stream()` and `from_stream()` functions @NiklasRosenstein Feature Add support for `typing.Dict` subclasses @NiklasRosenstein","title":"0.6.0 (2020-09-10)"},{"location":"changelog/databind.json/#051-2020-09-09","text":"Type Description PR Issues Author Fix Fix Python 3.6 support for `typing.List` subclasses by reading the generic paraemter from the right object @NiklasRosenstein","title":"0.5.1 (2020-09-09)"},{"location":"changelog/databind.json/#050-2020-09-06","text":"Type Description PR Issues Author Feature Add `strict` argument to `register_json_converters()` which will allow converters for plain-old-datatypes to accept string representations as well @NiklasRosenstein","title":"0.5.0 (2020-09-06)"},{"location":"changelog/databind.json/#041-2020-09-06","text":"Type Description PR Issues Author Fix conversion of values of a `List` subtype *from Python* are now converted to a built-in `list` instead of the same `List` subtype @NiklasRosenstein","title":"0.4.1 (2020-09-06)"},{"location":"changelog/databind.json/#040-2020-09-06","text":"Type Description PR Issues Author Feature support `@datamodel(serialize_as)` in `ModelConverter` @NiklasRosenstein","title":"0.4.0 (2020-09-06)"},{"location":"changelog/databind.json/#030-2020-08-29","text":"Type Description PR Issues Author Improvement `ArrayConverter` now supports subclasses of the `typing.List` generic @NiklasRosenstein","title":"0.3.0 (2020-08-29)"},{"location":"changelog/databind.json/#020-2020-08-29","text":"Type Description PR Issues Author Improvement update type hints to pass mypy checks @NiklasRosenstein Improvement add DEBUG log when `MixtypeConverter` is unable to convert a value at all to make debugging easier @NiklasRosenstein Fix accept `datetime.date`/`datetime.datetime` objects when converting to python if the target type is a respective match (rather than forcing a string as an input) @NiklasRosenstein","title":"0.2.0 (2020-08-29)"}]}